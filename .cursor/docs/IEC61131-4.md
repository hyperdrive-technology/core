# Chapter 4

## Title

4 The Programming Languages of IEC 61131-3

## Introduction

- IEC 61131-3 provides three textual languages and three graphical languages for writing application programs. The textual languages are:
- -Instruction list IL, -Structured Text ST, -Sequential Function Chart (textual version).
- The graphical languages are:
- -Ladder Diagram LD, -Function Block Diagram FBD, -Sequential Function Chart SFC (graphical version).
- The code part of the textual language ST consists of a sequence of statements and the code part of the textual language IL of a sequence of instructions.
- Statements in ST, a high-level language, consist of a combination of ST keywords which control the program execution and so-called expressions. Expressions, consisting of operators/ functions and operands, are evaluated at run time.
- In IL, an instruction consists of an operator or a function plus a number of operands (parameters). An operator usually has one (or no) operand and a function may have one or more (or no) parameters.
- The graphical languages use graphic elements to formulate the desired behaviour of the PLC. Connecting lines or so-called connectors indicate the data flow between functions and function blocks.
- In the following sections, the fundamental structure of the language or graphics constructs of each language are discussed; then the individual constructs are described in detail. Finally, an example is presented for every language.

## Section 4 1

### Title

4.1 Instruction List IL

### Introduction

Instruction List IL is a convenient assembler-like programming language. IL is universally usable and is often employed as a common intermediate language to which the other textual and graphical languages are translated.

### Subsection 4 1 1

#### Title

4.1.1 Instruction in IL

#### Paragraphs

- IL is a line-oriented language. An instruction, which is an executable command for the PLC, is described in exactly one line. Empty instructions in the form of blank lines are also allowed.
- A statement in IL consists of the elements represented in Figure 4.1.

#### Figure 4 1

##### Src

https://storage.googleapis.com/generativeai-downloads/images/100%204%20The%20Programming%20Languages%20of%20IEC%2061131-3.jpg

##### Alt

Figure 4.1. Instruction in IL; at least one blank space is required between operator and operand to distinguish these parts. Comments with (_ ... _) brackets are allowed wherever a blank space may be inserted.

##### Title

Figure 4.1. Instruction in IL; at least one blank space is required between operator and operand to distinguish these parts. Comments with (_ ... _) brackets are allowed wherever a blank space may be inserted.

#### Example 4 1

##### Code

MRun: LD %IX3.0 (_ Load bit from I/O _)
AND Timer_1 (_ Mask with variable: Release _)
ST PRun (_ Store value of Run Process _)
(_ Empty instruction _)
CALC Process (_ Call conditionally FB Process, if PRun = TRUE _)
JMPCN MRun (_ Jump, if PRun = FALSE _)

##### Caption

Example 4.1. Various IL instructions

#### Paragraphs After Example 4 1

- The label and the comment of an IL line are optional. As of Edition 2 [IEC 61131-3], comments are allowed not only at the end of a line, but wherever a blank space may be inserted, as in the other languages. For ease of reading, however, the former convention of inserting comments only at the end of a line is continued to be applied in this book.
- Labels are necessary to enable jumps in program execution to be performed from lines elsewhere in the program. A label on an otherwise empty line is allowed; the subsequent lines will be executed.
- The individual operators/functions describe the desired operation; see Sections 4.1.3 and 4.1.4. The operands and input parameters are explained in Chapter 3 and Appendices A and B.
- Comments are identical in all languages and are delimited by a pair of asterisks and brackets (\* \*). This construct is used for informal comments on the contents of a line.
- There is no defined format (such as column number) for the operators or operands; both parts can be separated by any number of blank spaces or tabs (see Example 4.1). The first character of an operator can start in any column.
- Note: The semicolon “;” is not allowed in IL, either as a “start of comment” character (as used in many assemblers) or as a statement terminator (as used in Structured Text).

### Subsection 4 1 2

#### Title

4.1.2 The universal accumulator (Current Result)

#### Paragraphs

- Standard assemblers are usually based on a real (hardware) accumulator of a processor, i.e. a value is loaded into the accumulator, further values are added, subtracted, ... and the result of the accumulator may finally be stored in a memory location.
- IL also offers an accumulator called the “Current Result” (CR) . However, the CR does not have a fixed number of bits like real hardware accumulators. The IL compiler ensures that a virtual accumulator (including accumulator stack) of any storage width is always available. The number of bits depends on the data type of the operand being processed. The data type associated with the CR also changes to match the data type of the most recent operand.
- Unusually for an assembler, IL has no specific processor status bits. The evaluation of a comparison operation produces a Boolean 0 (FALSE) or 1 (TRUE) result in the CR. Subsequent conditional jumps and calls use the TRUE or FALSE content of the CR as the condition during execution of the conditional jump or call.

#### Example 4 2

##### Code

VAR
FirstOperand, SecondOperand, Result: INT := 10;
StringOp: String[30] := ‘12345678901234567890’;
StringRes: String[25];
END_VAR
...
B1: LD FirstOperand (_ 10 {INT} _)
ADD SecondOperand (_ 20 {INT} _)
ST Result (_ 20 {INT} _)
GT 0 (_ TRUE, because 20 > 0 {BOOL} _)
JMPC B2
(_ jump, because CR=TRUE; present value of CR remains {BOOL} _)
JMP FarAway (_ CR is not defined or present value: _)
(_ implementation-dependent _)
B2: LD StringOp (_ 12345678901234567890 {STRING} _)
ST StringRes (_ 12345678901234567890 {STRING} _)
(_ .. _)
FarAway: (_ ... _)

##### Caption

Example 4.2. The universal accumulator of IL. The value of the “Current Result” (CR) and its current data type (in {} brackets) after execution of the instruction are shown in the instruction comments.

#### Paragraph After Example 4 2

A CR (Current Result) can be of type:

#### Cr Types

- Elementary data type,
- Derived data type (structure, array, etc.),
- Function block type.

#### Paragraphs After List

- The data capacity of the Current Result (the number of bits) is unimportant, as is shown by the character string operation in Example 4.2.
- IL demands that two consecutive operations must be compatible; i.e. the data type of the current CR must be the same as the subsequent instruction data type.
- In Example 4.3, an ADD operator with an operand of type INT requires the same data type in the CR (from the preceding instruction) to perform correctly.

#### Example 4 3

##### Code

VAR_INPUT
FirstOperand: INT;
END_VAR
VAR
SecondOperand, ThirdOperand: INT := 10;
WordVar: WORD;
END_VAR
LD 1 (_ 1 {INT} _)
ADD FirstOperand (_ 11 {INT} _)
ST SecondOperand (_ 11 {INT} _)
LT ThirdOperand (_ FALSE {BOOL} _)
AND WordVar (_ Error: WordVar is of type WORD, not BOOL as CR _)
(_ Data type mismatch _)
ST Exam43

##### Caption

Example 4.3. IL program containing an error: The data type of the CR (BOOL) does not match the data type of the “AND WordVar” instruction, which requires type WORD.

#### Paragraph After Example 4 3

Some operators change the type of the CR, as can be seen from Examples 4.2 and 4.3.

#### Table 4 1

| Influence of the Group of Operators on the CR | Abbrev. | Example Operators                                                                                                                                             |
| --------------------------------------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Create                                        | C       | LD                                                                                                                                                            |
| Process                                       | P       | GT                                                                                                                                                            |
| Leave unchanged                               | U       | ST; JMPC                                                                                                                                                      |
| Set to undefined                              | -       | CAL = Unconditional call of a function block. (The following instruction has to load the CR anew, because on return from the FB the CR has no defined value.) |

#### Caption Table 4 1

Table 4.1. Modification of the CR by different groups of operators

#### Paragraph After Table 4 1

The list in Table 4.1 shows the different types of influence an operator can have on the CR. We will refer to this table later.

### Subsection 4 1 3

#### Title

4.1.3 Operators

#### Paragraphs

- Leave unchanged means that an instruction passes the CR of the preceding instruction to the following one, without a change of value and type.
- Set to undefined means that the subsequent instruction cannot use the CR. The first instruction in an FB (called via CAL) must therefore be a load (LD), jump (JMP), FB call (CAL) or return (RET) because these operations do not require a valid CR.
- The IEC 61131-3 itself does not define operator groups; however, the groups help to explain more clearly the rules that are needed to combine the IL instructions successfully. The IEC describes the influence and evaluation of the CR only in a rudimentary manner. In the case of operations like AND and OR, the type and value of the CR before and after the operation is well defined. However, the standard does not discuss the validity of the CR value and data type after an unconditional jump. The operator groups referred to in the subsequent tables should therefore be seen as an aid in understanding the standard; they are an interpretation of the standard, but not part of it. They can be implemented differently in different programming systems.
- This section describes all the operators defined for IL. Some operators have extensions called modifiers. An operator combined with a modifier like N, ( or C has an extended meaning.
- Modifiers in detail:
- -N Negation of operand, -( Nesting levels by parenthesis, -C Conditional execution of operator (if CR=TRUE).
- The functionality of these modifiers is explained by means of the subsequent examples.

#### Negation of Operand

##### Title

Negation of the operand.

##### Paragraph 1

The operand is negated before carrying out the instruction:

##### Example 4 4

###### Code

VAR Var1: BOOL := FALSE; END_VAR
LDN FALSE (_ TRUE {BOOL} ; equivalent to LD 1 _)
ANDN Var1 (_ TRUE {BOOL} _)

###### Caption

Example 4.4. Negation of the operand by the modifier N. The value and type {} of the current result CR are shown in the comment after the instruction.

#### Nesting Levels

##### Title

Nesting levels by parenthesis.

##### Paragraphs

- It is possible to perform a logic operation on the CR and the result of a whole sequence of instructions by using the parenthesis modifier. When the “(”modifier is detected, the operator type and the current CR value and data type are “saved” and a new value and type are loaded in the CR. When the closing parenthesis “)” is detected, the deferred value and type are “retrieved” and are operated on using the modified operator and the current CR value. The result is stored in the CR.
- The standard does not describe how the deferred CR is saved and restored but typically a system stack is used for storing temporary data.

##### Example 4 5

###### Code

LD Var1 (_ Load value of Var1 in CR and then defer it _)
AND( Var2 (_ Calculate the expression in parentheses and _)
OR Var3 (_ associate the result with the Current Result (Var1) _)
)
ST Var4 (_ Store the result _)

###### Caption

Example 4.5. Blockwise computation of parenthesis operators. The sequence calculates the Boolean expression Var4 := Var1 ∧ (Var2 ∨ Var3).

##### Paragraph After Example 4 5

It is possible to program several levels of these parenthesised blocks:

##### Example 4 6

###### Code

LD 1 (_ 1 _)
ADD( 2 (_ 2 _)
ADD( 3 (_ 3 _)
ADD 4 (_ 7 _)
) (_ 9 _)
) (_ 10 _)
ST Var1 (_ 10 _)

###### Caption

Example 4.6. Computation of nested expressions in parentheses. The comment shows the value (result) of the Current Result after the operation.

##### Paragraph After Example 4 6

Note: The format of columns shown in Example 4.6 (“tabs”) is not mandatory. However, the ability to document nested expressions using indents increases the readability and therefore the quality of the program.
The Standard allows 2 ways of writing parenthesis operators; see Table 4.2

#### Table 4 2

| A) Short Form of Parenthesis Operator | B) Long Form of Parenthesis Operator |
| ------------------------------------- | ------------------------------------ |
| LD 1<br>ADD( 2<br>...<br>)            | LD 1<br>ADD(<br>LD 2<br>...<br>)     |

#### Caption Table 4 2

Table 4.2. Short form (a) and long form (b) of parenthesis operators

#### Conditional Execution

##### Title

Conditional execution of operators.

##### Paragraphs

- Note: It is not only the value of the CR which can be deferred using the parenthesis modifier, the data type can also be deferred so long as data type consistency is maintained throughout the entire instruction sequence.
- Several operators, like GT, generate a Boolean value stored in the Current Result. If the Boolean value is TRUE, the following (conditional) instruction (like a conditional jump) is executed. Otherwise, the instruction following the conditional instruction is given the control of the processor:

##### Example 4 7

###### Code

LD FirstOperand
GT 20 (_ Generate CR = TRUE if CR > 20, else FALSE _)
JMPC B2 (_ Jump to B2, if CR = TRUE, else next line _)
JMP FarAway (_ Jump to FarAway, independent of the CR _)

###### Caption

Example 4.7. Conditional and Unconditional form of the jump JMP/JMPC

##### Paragraphs After Example 4 7

- The next three tables give a complete overview of operators and modifiers.
- Some operators are reserved for Boolean data types and/or Bit String (ANY_BIT), some for generic data types, others for jumps and calls. The type compatibility of any standard function of the same name (such as ADD, ...) in IEC 61131-3 (see Appendix A) must be ensured.
- IEC 61131-3 demands Boolean operands or Bit String (ANY_BIT) for the operators of Table 4.3.

##### Table 4 3

| Operators                | Group of Operators a | Description                                               |
| ------------------------ | -------------------- | --------------------------------------------------------- |
| LD LDN                   | C                    | Load operand (negated) to CR                              |
| AND ANDN<br>AND ( ANDN ( | P                    | Boolean AND of the (negated) operand with the CR          |
| OR ORN<br>OR ( ORN (     | P                    | Boolean OR of the (negated) operand with the CR           |
| XOR XORN<br>XOR ( XORN ( | P                    | Boolean Exclusive-OR of the (negated) operand with the CR |
| NOT                      | P                    | Bit-wise Boolean negation (unit complement)               |
| ST STN                   | U                    | Store CR to the operand                                   |
| S                        | U                    | Set operand TRUE, if CR=1                                 |
| R                        | U                    | Set operand FALSE if CR=1                                 |
| )                        | P                    | Closing parenthesis; evaluate deferred operation          |

##### Table 4 3 Footnote

a Description see Table 4.1.

##### Caption Table 4 3

Table 4.3. Operators with Boolean and Bit String operands (Type ANY_BIT)

##### Paragraph After Table 4 3

Why do we need the definition of the “parenthesis” modifier? IEC 61131-3 defines standard functions like AND that allow data type ANY_BIT und thus adequately extend the operator functionality. However, in IL, it is not possible to include a computation result in a function as an operand as is allowed in ST or FBD. Therefore the parenthesis modifier was defined to make such computations possible.

##### Example 4 8

###### Code

a) Call by std. function/operator
LD V0
AND V1 OR V2 (_ Error _)
ST V3
(_ Attention: result not _)
(_ identical to _)
(_ LD V0 _)
(_ AND V1 _)
(_ OR V2 _)
(_ ST V3 _)

b) Operator
LD V0
AND( V1
OR V2
)
ST V3

c) ST
V3 := V0 AND (V1 OR V2);

d) FBD
V1 -->|>=1|-->|&|--> V3
V2 -->| | | |
V0 --------->| |

###### Caption

Example 4.8. This shows how complex expressions of logical operators/std. functions are handled as a sequence of instructions using the parenthesis modifier.

##### Paragraph After Example 4 8

The operators S and R are abbreviations for conditional storing. The operator S stands for “Store Conditional STC”, R is the notation for “Store Conditional Not STCN”.

##### Table 4 4

| Operators | Group of Operators a | Description                           |
| --------- | -------------------- | ------------------------------------- |
| LD        | C                    | Load operand to CR                    |
| ST        | U                    | Store CR to operand                   |
| ADD ADD ( | P                    | Add operand to CR                     |
| SUB SUB ( | P                    | Subtract operand from CR              |
| MUL MUL ( | P                    | Multiply operand with CR              |
| DIV DIV ( | P                    | Divide CR by operand                  |
| MOD MOD(  | P                    | Modulo division                       |
| GT GT (   | P                    | CR > operand (greater than)           |
| GE GE (   | P                    | CR >= operand (greater than or equal) |
| EQ EQ (   | P                    | CR = operand (is equal)               |
| NE NE (   | P                    | CR <> operand (is not equal)          |
| LE LE (   | P                    | CR <= operand (less than or equal)    |
| LT LT (   | P                    | CR < operand (less than)              |
| )         | P                    | Closing parenthesis level             |

##### Table 4 4 Footnote

a Explanation see Table 4.1.

##### Caption Table 4 4

Table 4.4. Operators for operands of generic numeric data type (type ANY_NUM)

##### Paragraphs After Table 4 4

- Table 4.4 also includes the operators LD and ST. Both can be used not only for Boolean data types but also for all data types. The property that these operators support data of type ANY is similar to the functionality of “overloading of functions”. The data type of the variable/constant operand defines the operator data type. It is the compiler’s responsibility to activate the correct operator for the given data type.
- Operators comparing two values (CR and operand) generate TRUE in the CR when the condition is TRUE, otherwise FALSE.

##### Table 4 5

| Operators     | Group of Operators a | Description                                              |
| ------------- | -------------------- | -------------------------------------------------------- |
| JMP           | - or Ub              | (Un)conditional jump to a jump label                     |
| JMPC JMPCN    | U                    | -                                                        |
| CAL           | -                    | (Un)conditional call of a function block                 |
| CALC CALCN    | U c                  | -                                                        |
| RET           | - or Ud              | (Un)conditional return from a function or function block |
| RETC RETCN    | U                    | -                                                        |
| Function name | Pc                   | Function call                                            |

##### Table 4 5 Footnotes

- A Explanation see Table 4.1.
- B Implementation-dependent
- C Valid for following operator (but undefined at start of function or FB execution!)
- D For functions: Function value (“U“)

##### Caption Table 4 5

Table 4.5. Operators for Jump and Call

##### Paragraph After Table 4 5

The operand of a jump operator is a label. The operand of an FB call (CAL, CALC, CALCN) is the name of the FB instance.

### Subsection 4 1 4

#### Title

4.1.4 Using functions and function blocks

#### Calling a Function

##### Title

Calling a function.

##### Paragraphs

- A function is called in IL by simply writing the name of the function. The actual parameters follow separated by commas. The syntax is equivalent to that of an operator with several operands.
- Formal parameters can also be assigned actual values line by line using ":=". However, this does not apply to the operators valid in IL, where only the above alternative of value assignment is allowed.
- The first parameter of a function is the Current Result (CR). Therefore, this value must be loaded into the CR just before the function is called. The first operand, which is used in the function call, is actually the second parameter of the function and so on, see Example 4.9.

##### Example 4 9

###### Code

Actual parameters:
LD 1
LIMIT 2, 3

With formal parameters:
LIMIT(
MN := 1,
IN := 2,
MX := 3
)

With formal parameters:
LIMIT(
MX := 3,
IN :=2,
MN :=1
)

###### Caption

Example 4.9. Equivalent calls of a function using actual parameters and formal parameters, latter example in an arbitrary sequence

##### Paragraphs After Example 4 9

- A function returns at least one output value. This is stored in the CR and has the data type specified for the function. Other output parameters of the function are returned through parameter assignments, see Section 2.5 and Example 4.10. When a function is called without formal parameters, the sequence of declarations must be adhered to. In the case of formal parameter assignments, this is done line by line with a concluding parenthesis.

##### Example 4 10

###### Code

LIMIT(
EN:= ErrorCond,
MN :=1,
IN :=2,
MX := 3,
ENO => ErrorCondLim (_ => indicates: ENO is output parameter _)
)

###### Caption

Example 4.10. Function call equivalent to that in example 4.9 with formal parameters with execution control EN/ENO and output parameter ENO. The result of LIMIT is stored in the CR.

##### Paragraphs After Example 4 10

- The programming system assigns the function value to a variable with the function name; this name is declared automatically and does not have to be specified separately by the user in the declaration part of the calling function block.
- The parameters EN/ENO are used according to the functionality described in Section 2.7.1. A POU with EN/ENO parameters must be called with formal parameters, and not only with actual parameters.

##### Example 4 11

###### Code

Function call:
VAR
FirstFunPar: INT :=10;
Par2: INT := 20;
Par3: INT := 30;
Sum: INT;
END_VAR
LD FirstFunPar
UserFun Par2, Par3
(_ Second call: _)
UserFun Par2, Par3
ST Sum

Definition of the function
FUNCTION UserFun : INT
VAR \_INPUT
FunPar1, FunPar2 , FunPar3: INT;
END_VAR
LD FunPar1
ADD FunPar2
ADD FunPar3
ST UserFun (_ Ret value,can be omitted _)
RET (_ Can also be omitted_)
END_FUNCTION

###### Caption

Example 4.11. Two calls of the user function, UserFun. At the first call, FunPar1 has the value 10, at the second, 60. FunPar2 is 20 and FunPar3 is 30. At the end 110 is stored in Sum.

#### Calling a Function Block

##### Title

Calling a function block.

##### Paragraphs

- An FB can be activated by the operator CAL (or CALC for conditional and CALCN for conditional negated calls). IEC 61131-3 describes three methods of passing parameters to an FB in the IL language:
- 1. Using a call including a list of actual input and output parameters in brackets, 2) Loading and saving the input parameters before calling the FB, 3) Calling “implicitly” by using the input parameters as operators.
- Method 3 is only valid for standard FBs, not for user FBs. This manner of activating FBs is seldom used in practice.
- These three call methods are demonstrated in the following example.

##### Figure 4 2

###### Src

https://storage.googleapis.com/generativeai-downloads/images/4.1%20Instruction%20List%20IL%20111.jpg

###### Alt

Figure 4.2. Standard function block TON with input and output parameters

###### Title

Figure 4.2. Standard function block TON with input and output parameters

##### Example 4 12

###### Code

VAR
Rel, Out: BOOL := 0; (_ Release - Input; Output _)
Time1: TON; (_ Std - FB TON has the formal parameters _)
(_ IN, PT (input) and Q, ET (output _)
Value TIME; (_ Set - Input _)
END_VAR

(_ Method 1 _)
(_ Supplying the parameters: _)
(_ Call: _)
CAL Time1 (
IN:=Rel,
PT:= t#500ms,
Q=>Out, (_ Output p. 1 _)
ET=>VALUE (_ Output p. 2 _)
)

(_ Method 2 _)
(_ Supplying the parameters: _)
LD t#500ms
ST Time1.PT
LD Rel
ST Time1.IN
(_ Call: _)
CAL Time1

(_ Method 3 _)
(_ Supplying the parameters: _)
LD t#500ms
PT Time1
LD Rel
(_ Call: _)
IN Time1

(_ Utilisation of the output parameters _)
LD Time1.Q
ST Out
LD Time1.ET
ST Value

###### Caption

Example 4.12. Time1 declared as an instance of FB TON, the loading of the input parameters, the call of the instance and the evaluation of the output parameters.

##### Paragraphs After Example 4 12

- The declaration part and the evaluation of the output parameters are identical for all three methods. The methods differ only in the supplying of the input parameters and the FB call; see also Section 2.8.4.
- If a programming system supports several methods, the supply, call and evaluation methods can be mixed.
- In modification of method 1, a call can also be made with actual parameters, as in a function call. In this case, the actual parameter values are written in their defined sequence, separated by commas.
- Using method 3, the PT operator initialises the PRESET time. The IN operator starts the FB Time1. Method 3 will not change input parameters in a command line that are not addressed, i.e. the values from previous assignments will be used. Method 3 should be used with care because it is not always clear when calling a function block whether an input parameter is defined or whether the function block is executed.

### Subsection 4 1 5

#### Title

4.1.5 IL example: Mountain railway

#### Paragraphs

- The following example is a simplification of a control system programmed for a mountain railway.
- It is written here in IL. The graphical representation in LD is shown in Section 4.4.5

#### Figure 4 3

##### Src

https://storage.googleapis.com/generativeai-downloads/images/4.1%20Instruction%20List%20IL%20113.jpg

##### Alt

Figure 4.3. Example of a mountain railway with three stations and one cabin.

##### Title

Figure 4.3. Example of a mountain railway with three stations and one cabin.

#### Paragraph After Figure 4 3

The program has to control the following features:

#### Features List

- 1. The sensors S1, S2, S3 send TRUE (1) when the cabin arrives at one of the stations. The counter StationStop stores the total number of stops at stations.
- 2. The motor to move the cabin is controlled by the following signals: _ Direction: Forward (TRUE) / Backward (FALSE) (retained variables) _ StartStop: Start (TRUE), Stop (FALSE)
- 3. Inside the cabin, a switch DoorOpenSignal is used to open/close the door. DoorOpenSignal equal to TRUE signals “Open the door”, FALSE “Close the door”.
- 4. The motor to move the door has two actuators: OpenDoor and CloseDoor. Both actuators are triggered by a rising edge of one of the two signals.
- 5. A button MRStart starts the whole system. The button MREnd is used to shut down the system.
- 6. A danger signal must be activated between shutdown of the railway and a new start.

#### Paragraph After List

A detailed description of this control program can be found in Section 4.4.5.

#### Example 4 13

##### Code

FUNCTION_BLOCK MRControl
VAR_INPUT
MRStart: BOOL R_EDGE; (_ Edge-triggered button to start the railway _)
MREnd: BOOL; (_ Switch for initiation of the end of operation _)
S1, S2, S3: BOOL R_EDGE; (_ Edge-triggered sensors in every station _)
DoorOpenSignal:BOOL; (_ Switch to open the door. 1: open; 0: close! _)
END_VAR
VAR_IN_OUT
StartStop: BOOL; (_ Cabin moving: 1; not moving: 0 _)
END_VAR
VAR_OUTPUT
OpenDoor: BOOL; (_ Motor to open the door _)
CloseDoor: BOOL; (_ Motor to close the door _)
END_VAR
VAR_OUTPUT RETAIN
EndSignal: BOOL; (_ Warning signal for Power Off (retained) _)
END_VAR
VAR
StationStop: CTU; (_ Standard FB (counter) for cabin stops _)
DoorTime: TON; (_ Standard FB (delayed start) of cabin _)
END_VAR
VAR RETAIN
Direction: BOOL; (_ Current direction up or down _)
END_VAR
(_ System running for the first time after power on? Yes: Reset the end signal _)
(_ activated by the last shutdown _)
LD MRStart (_ The first call? _)
R EndSignal (_ Yes: Reset the warning signal _)
JMPC ResCount
(_ Not the first call! _)
JMP Arrive
(_ Reset the station counter _)
ResCount: LD 1
ST StationStop.RESET (_ Reset the counter _)
LD 9999
ST StationStop.PV (_ Maximum _)
CAL StationStop (_ Call of the FB instance StationStop _)
JMP CloseCabin
(_ Increase the counter StationStop when the cabin arrives at a station_)
Arrive: LD S1 (_ Sensors are edge-triggered! _)
OR S2
OR S3
(_ Stop if the CR is now TRUE _)
R StartStop (_ Stop cabin _)
CALC StationStop (RESET:= 0,CU:=1) (_ If stop-> increase counter _)
(_ Change of direction? _)
LD S1
XOR S3
JMPCN NoDirChange (_ either S1 or S3 are TRUE? _)
(_ Change direction of cabin _)
LD Direction
STN Direction
(_ Condition to open cabin: cabin stops and door open switch is activated _)
NoDirChange: LD DoorOpenSignal
ANDN StartStop
ST OpenDoor
(_ End signal for railway and cabin in a station -> POU end _)
LD MREnd (_ Power-off activated? _)
ANDN StartStop
S EndSignal
JMPC PouEnd
(_ Door switch signals to shut the door _)
CloseCabin: LD DoorOpenSignal
STN CloseDoor
(_ Cabin start 10 seconds after activation of the door switch _)
LDN DoorOpenSignal
ANDN StartStop
ST DoorTime.IN
LD T#10s
ST DoorTime.PT
CAL DoorTime
LD DoorTime.Q (_ Time finished? _)
S StartStop
RET (_ Return to the calling POU _)
PouEnd:
END_FUNCTION_BLOCK

##### Caption

Example 4.13. Control of a mountain railway by FB MRControl written in IL. Please refer to the CD for an optional version of the calling PROGRAM (MRMain.POE).
