# Chapter 7

## Title

7 Innovative PLC Programming Systems

## Introduction

This chapter goes beyond the specifications of IEC 61131-3 and outlines further requirements placed on programming systems in the marketplace. These mainly stem from the special conditions to be met in the PLC environment; requirements and solutions are presented based on the IEC 61131-3 programming culture.

## Section 7 1

### Title

7.1 Requirements of Innovative Programming Tools

### Paragraph 1

The performance of a PLC programming system can be judged by three criteria:

### Criteria List

- Technological innovation,
- Fulfilment of PLC-specific requirements,
- Cost/benefit ratio.

### Paragraph 2

The fact that IEC 61131-3 no longer makes a strict distinction between PLC, process computer and PC has a major effect on programming. With the aid of various backend compilers, one and the same programming system can be used to generate user code for

### Plc Types List

- Compact PLC (device, mostly in DIN rail format, with integrated I/O connections; proprietary operating system),
- Modular PLC (device, mostly 19” PCB, communicating via a multitude of I/O cartridges in the backplane; proprietary operating system),
- Embedded Controller (front-end computer with network connection (e.g. Profibus or CAN); proprietary operating system)
- Embedded PC (PC hardware-based; mostly Windows CE or (Realtime) Linux)
- Standard PC (extended by I/O boards, Windows realtime extension, uninterruptible power supply, …)

### Paragraph 3

All of the diverse combinations can be handled with a single programming system or programming method. As a rule, the programming systems run on Windows XP or Vista and are connected to the target PLC via serial connections or LAN.

## Section 7 2

### Title

7.2 Decompilation (Reverse Documentation)

### Paragraphs

- Reverse documentation is a traditional requirement of the PLC market. Ideally, it should be possible to read out a PLC program directly from the controller, in order to modify it on-site at the machine, for example, far away from the office where it was developed. Maintenance personnel want to be able to read, print and modify the PLC program without having the original sources available on a PC.
- Decompilation is the ability to retrieve all the information necessary to display and edit a POU directly from the PLC.
- Decompilation services can be graded according to the facilities offered:
- -No decompilation, -Decompilation with symbols and comments, -Decompilation including graphics, -Sources stored in the PLC.

### Subsection 7 2 1

#### Title

7.2.1 No decompilation

#### Paragraphs

- Most IEC 61131-3 programming systems do not support decompilation. The number of freely selectable symbolic names required to decompile a program has steadily grown and they cannot be stored in the limited memory available on controllers.
- It is rare to find PLCs with processor chips specially developed by the manufacturer (e.g. ASIC or bit slice) and using their own specially written machine code. For cost reasons it is more common to use standard processors. It is much more difficult to decompile the machine code from these standard processors back to Instruction List or Structured Text than it is with custom processors.
- It is essential to be able to modify programs after commissioning. It is currently state of the art to keep all information related to a project (sources, libraries, interface and configuration information) on a hard disk drive. Ideally, the sources should be in a language-independent form so that they can be displayed in any programming language. Precautions must be taken in the software to ensure that the program on the controller and the program saved on the hard disk are identical before allowing modification.

### Subsection 7 2 2

#### Title

7.2.2 Decompilation with symbols and comments

#### Paragraphs

- The binary code of a program as read out from the PLC will not suffice to create a compilable source. The PLC should provide lists specifying the current wiring (CONFIGURATION). This includes the assignment of symbolic variables to physical addresses, global variables, the mapping of programs to tasks and resources, etc.
- Symbolic information (like variable names and jump labels) is typically not contained in the executable code. A symbol table, created during program development and sometimes including comments on declarations and instructions, must be stored in the PLC to enable decompilation of the program directly from the PLC.

### Subsection 7 2 3

#### Title

7.2.3 Decompilation including graphics

#### Paragraph 1

The PLC contains executable code. To be able to display this code graphically on the PC (in Ladder, Function Block Diagram or SFC), the code must either conform to certain syntax rules or it must be augmented by additional information. Using the first method results in shorter programs, but restricts the facilities for graphical representation.

### Subsection 7 2 4

#### Title

7.2.4 Sources stored in the PLC

#### Paragraph 1

The complex architecture of today’s IEC 61131-3 programming systems makes it more and more difficult to pack all the information into the binary code. To have all the information needed for decompilation available on the PLC, a simple solution is to store the entire project information in compressed format in a separate slow, low-cost memory within the PLC. From there, this information can easily be transferred to the PC and edited using the programming system in the same way as during program development.

## Section 7 3

### Title

7.3 Language Compatibility

### Paragraphs

- The five languages of IEC 61131-3 have a special relationship with one another.
- Sequential Function Chart with its two methods of representation (textual and graphical) is different from the other languages because it is not used for formulating calculation algorithms, but for structuring programs and controlling their execution.
- The logic operations and calculations themselves are defined in one of the other languages and invoked from SFC via action blocks, see Examples 4.54 and 4.55 in Section 4.6.6.
- Each program consists of blocks (POUs), which invoke each other by means of calls. These blocks are independent of each other and can be written in different languages, even languages not defined by IEC 61131-3, provided the calling conventions of IEC 61131-3 are observed.
- IEC 61131-3 does not go beyond defining common calling interfaces between blocks written in different languages. The question is: Is it necessary to be able to display code written in one IEC 61131-3 language in another IEC 61131-3 language?
- The use of different languages within the same program and the ability to display, print and edit POUs in any IEC 61131-3 language is discussed in the next two sections under the headings Cross-compilation and Language independence.

### Subsection 7 3 1

#### Title

7.3.1 Cross-compilation

#### Paragraphs

- IEC 61131-3 does not require that a POU developed in one language should be able to be displayed in another language. The argument about the need for this has been going on as long as PLCs have been in existence.
- What are the reasons for asking for this feature?

#### Motivation

##### Title

The motivation for cross-compilation

##### Paragraphs

- One important reason for wanting to be able to cross-compile parts of a program are the different levels of education and areas of activity of technicians and engineers. Depending on their field, they tend to be trained in different programming languages, making it difficult for them to work together.
- In the automotive industry in the US, Ladder Diagram is the preferred language, while the same industry in Europe prefers Instruction List or Structured Text. In the plant construction industry, a functional language like FBD will be preferred. A computer scientist should have no difficulties using Structured Text. So, do we need a different language for every taste, but with editing facilities for all?
- Some languages are better suited for certain problems than others. For example, memory management routines are obviously easier to read and write in IL or ST than in Ladder Diagram. A control program for a conveyor is clearer in Ladder Diagram than in ST. SFC is the best choice for a sequential control system.
- In many cases, it is not so easy to select the right language. The same section of a program is frequently even needed by different users.
- For example, a PLC manufacturer may provide POUs written in IL to support users in handling I/O modules. The user may be a conveyor belt manufacturer, using the PLC to monitor and control limit switches and motors, and preferring to work with Ladder Diagram. So the programmer modifies the code provided in IL to his needs, using Ladder Diagram to do so. The conveyor may then be supplied to a plant construction company where all programs are written in FBD, and the I/O control programs will be required for complete and uniform documentation.

#### Different Approaches

##### Title

Different approaches in graphical and textual languages.

##### Paragraphs

- One difficulty with cross-compilation lies in the different ways of looking at a calculation. LD and FBD have their roots in Boolean or analogue value processing: there is “power flow”, or not; values are propagated and calculated in parallel and not clocked. Textual languages, like IL and ST, are procedural, i.e. instructions are executed one after the other.
- This becomes obvious when looking at the network evaluation in Section 4.4.4. Example 7.3 gives an example in Ladder Diagram (FBD would be similar).

##### Example 7 3

###### Code

a) IL
LD Var1
JMPC Label1
ST Var2
AND Var3
JMPC Label2

b) LD
0001:
--| |-- Var1 --( )-- Var2 --| |-- Var3 --( )-- Label1
|
--| |-- Var3 --( )-- Label2

###### Caption

Example 7.3. Sequential execution of a program section in IL compared to parallel execution of a network in Ladder Diagram. This makes cross-compilation difficult.

##### Paragraphs After Example 7 3

- According to the evaluation rules given for graphical languages (see Section 4.4.4), Var2 will always be assigned a value. If this network is converted from IL as it stands, Var2 will be assigned a value only if Var1 equals FALSE. Otherwise it would be necessary to rearrange the elements before cross-compiling (all ST instructions before a conditional JMP or CAL). This would change the graphical appearance of the network when cross-compiled to Ladder Diagram.
- Looking at the procedural (IL) sequence and the simultaneous evaluation in Example 7.3, the IL sequence converted to Ladder is misleading. When Var1 and Var3 are TRUE, Label1 and Label2 are also TRUE. The IL sequence jumps to Label1; in the Ladder Diagram version both labels are addressed in accordance with the evaluation rules of Ladder, and the next network to be activated is unclear.
- This problem of cross-compilation is solved in many of the programming systems that possess this functionality by:
- -not allowing further logic operations after an assignment in graphical networks, -evaluating the code part of a graphical network from top to bottom (Example 4.40) and stopping evaluation when a control flow instruction is being executed.

#### Differences Affect Cross Compilation

##### Title

Differences in languages affect cross-compilation.

##### Paragraphs

- Not all of the languages can be cross-compiled to each other. SFC is a language for structuring applications, making use of the other languages, but having a completely different design. We shall therefore only discuss cross-compilation between IL, ST, LD and FBD.

#### Restrictions Ld Fbd

##### Title

Restrictions in LD/ FBD.

##### Paragraphs

- Jumps can be made using labels, but are somewhat contradictory to the concept of “parallel” networks. Some functions, like management of system resources (stack operations), can only be expressed in very complicated, unreadable programs.
- Constructs like CASE, FOR, WHILE or REPEAT are not available in these languages and can only be implemented by using standard functions like EQ and complex network arrangements.
- Unlike ST, these two languages allow only simple expressions to be used to index arrays.
- LD is designed to process Boolean signals (TRUE and FALSE). Other data types, like integer, can be processed with functions and function blocks, but at least one input and one output must be of type BOOL and be connected to the power rail. This can make programs hard to read. For non-Boolean value processing FBD is better suited than LD.
- Not all textual elements have a matching representation in the graphical languages. For example, some of the negation modifiers of IL are missing in LD and FBD: JMP, JMPC, RET and RETC are available, but JMPCN and RETCN are not. These can be formulated by the user with additional logic operations or supplementary (non-standard) graphical symbols can be included in the programming system.

#### Restrictions Il St

##### Title

Restrictions in IL/ ST.

##### Paragraphs

- The notion of a network, as used in the graphical languages LD and FBD, is not known in IL or ST.
- In Ladder Diagram, attributes like edge detection (P, N) can be expressed by graphical symbols. This representation of attributes in the code part of a program does not comply with the strict concept of expressing the attributes of variables in the declaration part. There are no matching elements in the textual languages for these graphical symbols.
- The use of EN and ENO poses another problem, as no matching element is available in IL or ST. Each user-defined function must evaluate EN and assign ENO a value to be useable in graphical languages. If EN and ENO are used in graphical languages and not used in textual languages, two versions of standard functions are needed (with and without EN/ENO processing), see Section 2.7.1.

#### Cross Compilation Il St

##### Title

Cross-compilation IL / ST.

##### Paragraphs

- A high-level language (ST) can be converted more easily and efficiently into a low-level, assembler-like language (IL) than vice versa. In fact, both languages have some features that make cross-compilation into the other difficult. For example:
- -ST does not support jumps, which have to be used in IL to implement loops. This makes cross-compilation of some IL programs difficult.
- -IL supports only simple variables for array indices and actual parameters for function and function block calls, whereas in ST complex expressions may also be used.

#### Full Cross Compilation

##### Title

Full cross-compilation only with additional information.

##### Paragraphs

- If a system in Ladder Diagram allows multiple coils and/ or conditional instructions with different values within a network (corresponding to a one-output to many-input situation in FBD), see Example 7.4, auxiliary variables have to be used to cross-compile to IL. When cross-compiling this code part from IL or ST to Ladder Diagram, care has to be taken to avoid multiple networks being generated in the Ladder Diagram version.
- Small modifications of an IL program can, therefore, result in major changes in the Ladder cross-compiled form.

##### Example 7 4

###### Code

a) IL
LD Var1
ST Helper
AND Var2
ST Var3
LD Helper
AND Var4
ST Var5

b) LD
0001:
--| |-- Var1 --( )-- Helper
|
--| |-- Helper --| |-- Var2 --( )-- Var3
|
--| |-- Helper --| |-- Var4 --( )-- Var5

###### Caption

Example 7.4. If coils or conditional instructions are used in an LD network with different value assignments, direct cross-compilation is not possible. To cross-compile to IL, an auxiliary variable like Helper is necessary.

##### Example 7 5

###### Code

a) IL
LD Var1
OR ( Var3
AND Var4
ST Helper
)
AND Var2
OR ( Helper
AND Var5
)
ST Var7 (_ typically not allowed _)

b) LD
0001:
--| |-- Var1 --+--| |-- Var2 --( )-- Var7
| |
+--| |-- Var3 --| |-- Var4 --+--| |-- Var5 --+
|
+-------------+

###### Caption

Example 7.5. The limits of cross-compilation are reached when it comes to the compilation of complex parenthesised constructs and helper variables into a textual language.

##### Paragraphs After Example 7 5

- The Ladder network in Example 7.5, which looks perfectly clear in this graphical language, is not directly cross-compilable to IL. An auxiliary variable, like Helper, is necessary to temporarily store the intermediate result between Var3 and Var4, and several parentheses are needed. Storing a variable within a parenthesised expression is not explicitly prohibited in IEC 61131-3, but should be avoided because comparable operators, like conditional jumps, may also not be used within parenthesised expressions.
- Some programming systems automatically place graphical elements in the correct (optimum) position, depending on their logical relation. Other systems allow and require users to position the elements themselves. This topographical information needs to be stored in the form of comments in IL or ST, if a graphical representation is to be regenerated from the textual representation later. IL or ST programmers cannot reasonably be expected to insert this topographical information. In most programming systems, the information about the position of the graphical elements is therefore only kept in internal data storage and is lost when the program is cross-compiled to IL or ST. In most cases, there is no way back from the textual languages to the original graphical layout.

#### Quality Criteria

##### Title

Quality criteria for cross-compilation.

##### Paragraphs

- It has been explained that full cross-compilation in the theoretical sense cannot be achieved. The quality of a programming system with respect to cross-compilation depends rather on how well it meets the following conditions:
- 1. The rules of cross-compilation should be so easy to understand that the programmer can always determine the result. 2) Cross-compilation must not change the semantics of the POU (only local modifications, entities must stay together). 3) Cross-compilation should not affect the run time of the program. 4) Cross-compilation must not introduce side-effects (i.e. not affect other parts of the program). 5) Ambiguities must be resolved (see Example 7.3).
- As cross-compilation is not easy to achieve, many programming systems do not implement it.

### Subsection 7 3 2

#### Title

7.3.2 Language independence

#### Paragraphs

- The POU, as an independent entity, is an important item of IEC 61131-3. To invoke a POU in a program, only the external interface of the POU needs to be known, and no knowledge about the code contained within it is required. To design a project top-down, it should therefore be possible to define all the interfaces of the POUs first and fill in the code later.
- Once the external interface of a POU has been defined, it is typically made available to the whole project by the programming system. It consists of:
- -the function name and function type, plus the name and data type of all VAR_INPUT and -if applicable -VAR_OUTPUT parameters for a FUNCTION, -the function block name, the name and data type of all VAR_INPUT, VAR_OUTPUT, VAR_IN_OUT parameters and EXTERNAL references for a FUNCTION BLOCK, -the program name, the name and data type of all VAR_INPUT, VAR_OUTPUT, VAR_IN_OUT and VAR_ACCESS parameters and GLOBAL variables for a PROGRAM.
- One POU can invoke another function or function block instance without knowing which language the other POU has been programmed in. This means that the programming system does not have to provide a separate set of standard functions and function blocks for each programming language.
- This principle can even be extended to languages outside the scope of IEC 61131-3 as the caller needs no knowledge of the invoked block apart from its external interface. If the external interface and the calling conventions of an IEC 61131-3 programming system and a C compiler, for example, are compatible, it is equally possible to invoke a C subprogram.
- IEC 61131-3 expressly allows the use of other programming languages.

## Section 7 4

### Title

7.4 Documentation

### Paragraph 1

Different types of documentation are required to allow for efficient maintenance of applications and to support modern quality standards like ISO 9000:

### Documentation Types

- 1. Cross-Reference List. A table listing which symbols (variable name, jump label, network title, POU type or instance name etc.) are being used in which POUs.
- 2. Program Structure, giving an overview over the calling hierarchy of POUs. Each POU has a list giving the names of all POUs invoked from it. The Program Structure can be visualised graphically, or textually, with a nesting depth depending on the system.
- 3. Allocation List (Wiring List). A table giving the physical addresses of I/Os and the names of the variables assigned to these addresses.
- 4. I/O Map. A table of all I/O addresses used by the application, sorted by address. The I/O map is helpful in finding free I/O addresses when extending an application and for having the relation between PLC software and PLC hardware documented in a hardware-oriented manner.
- 5. Plant Documentation. A description of the entire plant, typically graphical. Each individual PLC will be only one “black box” in this documentation. The entire plant contains multiple PLCs, machines, output devices etc. The plant documentation is often generated with standard CAD programs, giving the topological grouping and connections between PLCs and other devices.
- 6. Program Documentation. Sources of POUs created with the programming system. When printed, these should closely match in structure and contents the representation on-screen while editing.
- 7. Configuration. The Configuration – as understood by IEC 61131-3 – describes which programs are to be executed on which PLC resources and with what run time properties.

### Paragraph After List

These types of documentation are neither required nor standardised by IEC 61131-3, but have become popular over the years for documenting PLC programs.

### Subsection 7 4 1

#### Title

7.4.1 Cross-reference list

#### Paragraph 1

The cross-reference list consists of:

#### Cross Reference List Items

- all symbolic names used in a program (or occasionally in an entire project),
- the data type of all variables, the function block type for instance names, the function types for functions plus declaration attributes (like RETAIN, CONSTANT or READ_ONLY) and the variable type (VAR_INPUT, ...),
- the name and type of the POU, including the numbers of all lines in which these variables and/or an instance with this POU type occur,
- the kind of access to this variable at this program location,
- the location of the declaration of this variable.

#### Paragraphs After List

- Some systems support a cross-reference list only for individual POUs, or provide it only for global and external data.
- The cross-reference list is helpful in finding program locations referencing variables during debugging.
- Different sorting criteria are usually supported. The entries are usually sorted alphabetically by symbolic name. They can also be sorted by symbol type (input, output, function name, instance name,...) or data type (BYTE, INT,...).

#### Example 7 6

##### Table

| Symbolic Name | POU Name  | POU Type | Line No.                   | Access | Data Type | Attribute | Var Type |
| ------------- | --------- | -------- | -------------------------- | ------ | --------- | --------- | -------- |
| Temp_Sensor   | SOND.POU  | Prog     | <pre><code>10</code></pre> | Decl   | INT       | Retain    | GLOBAL   |
| -             | SOND.POU  | Prog     | <pre><code>62</code></pre> | Read   | -         | -         | GLOBAL   |
| -             | CONTR.POU | FB       | <pre><code>58</code></pre> | Write  | -         | -         | EXTERN.  |

##### Caption

Example 7.6. Example of a cross-reference list sorted by symbolic name

### Subsection 7 4 2

#### Title

7.4.2 Allocation list (wiring list)

#### Paragraphs

- The allocation list lists all variables which are assigned to physical I/O addresses of a configuration, plus the access path, if supported.
- Sometimes, tools are provided for changing the assignment of symbols to physical addresses (rewiring). This often needs to be done when porting an application to another environment (e.g. another PLC with different I/O connections).

#### Example 7 7

##### Table

| Symbolic Name | I/O Address |
| ------------- | ----------- |
| Temp_Sensor_1 | %IB0        |
| Temp_Sensor_2 | %IB2        |
| Temp_Control  | %QB4        |
| Temp_Save     | %MB1        |

##### Caption

Example 7.7. Example of an allocation list (wiring list)

### Subsection 7 4 3

#### Title

7.4.3 Comments

#### Paragraphs

- Comments are an important part of program documentation. Application sources can be enhanced by descriptive comments at many locations (see Example 7.2):
- -In ST and IL, comments can be inserted wherever space characters are allowed, -IEC 61131-3 does not include any guidelines on comments in the graphical languages. However, network comments, preceding and describing a network, are a valuable aid in documentation.
- Some programming systems have menu settings to prevent (accidental) overwriting of the program and allow, for example, changes to be made in the comments only by service personnel.

## Section 7 5

### Title

7.5 Project Manager

### Paragraph 1

The task of the Project Manager is to consistently manage all information related to the implementation of a project. This includes:

### Project Manager Tasks

- Source information -The sources of all POUs created, with -type definitions, declarations of global data, definition of access paths with VAR_ACCESS,... -descriptions of the call interfaces of all POUs in order to check their usage, -Version control of all sources, -Access restrictions, sometimes with different access levels authenticated by passwords, for: -modifying POUs, -printing programs, -editing libraries.
- Object information -Compiled sources (intermediate code, object code, executable files), -Project creation procedures (call-dependence, creation and modification information for controlling time-dependent compiling operations, for example in MAKE or batch processes), -Libraries (standard functions, standard function blocks, manufacturer defined blocks, communication function blocks, user libraries).
- Online information -Data for assigning parameters to the project (recipes), -Device and configuration information (PLC hardware, I/O modules,...), -Additional information for online testing (symbol information, breakpoints,...), -Communication information (manufacturer-specific transfer protocols, interfaces).
- Documentation (e.g. cross-reference list, allocation list, program structure,...).

### Paragraphs After List

- The Project Manager administers and archives all this data. Why is a standard file manager (e.g. the Windows Explorer) not sufficient?
- POUs are interdependent. Multiple programs within one project can use the same POU, although it only exists as a single file. Function names and function block types have global scope throughout a project (whereas the scope of function block instances is limited to the POU they are defined in, unless they are explicitly declared GLOBAL).
- For every invocation of a POU (instance or function) the compiler and editors need interface information about the POU being invoked (types and names of parameters). In order to reduce the overhead of gathering the same information again and again every time it is needed, the Project Manager can store such information and supply it to other parts of the programming system when requested.
- Figure 7.2 shows the directory of a hard disk drive (D:), containing sub directories. In order to visualise the structure of a project, it is necessary to evaluate interdependences between calls and environmental factors to enable the relations to be displayed, see Figure 7.3.

### Figure 7 2

#### Src

https://storage.googleapis.com/generativeai-downloads/images/264%207%20Innovative%20PLC%20Programming%20Systems.jpg

#### Alt

Figure 7.2. Data for sources and libraries stored on disk (shown as drive D:\). The programming system should allow the user to create directories and sub-directories to resemble the project structure as far as supported by the operating system (e.g. Windows).

#### Title

Figure 7.2. Data for sources and libraries stored on disk (shown as drive D:\). The programming system should allow the user to create directories and sub-directories to resemble the project structure as far as supported by the operating system (e.g. Windows).

### Paragraph After Figure 7 2

The programming system should assist the programmer in understanding the structure of the project. One project can contain several configurations (PLCs), and each configuration can contain several resources (CPUs). See Chapter 6 for the description of a configuration. Each resource will have a specification of the hardware associated with it (Resource1 File). Each resource can execute multiple programs (Program1, ...), which are implemented in the form of POUs invoking other POUs. Two distinct instances of one POU, as shown in Figure 7.3, contained in different programs, can be described by the same POU stored in only one file on disk.

### Figure 7 3

#### Src

https://storage.googleapis.com/generativeai-downloads/images/7.5%20Project%20Manager%20265.jpg

#### Alt

Figure 7.3. The logical structure of a project consists of configurations, resources and a POU calling hierarchy. As this structure in most cases is not identical with the physical file and directory structure, e.g. Figure 7.2, additional visualisation aids are helpful.

#### Title

Figure 7.3. The logical structure of a project consists of configurations, resources and a POU calling hierarchy. As this structure in most cases is not identical with the physical file and directory structure, e.g. Figure 7.2, additional visualisation aids are helpful.

### Paragraphs After Figure 7 3

- Rules can be established for finding information. For example, to compile Program1 for Resource1, all user, system and manufacturer POUs used in the program have to be collected. If one of the POU names called appears more than once on the disk, the system has to take appropriate action (e.g. apply a rule to choose one, or issue an error message); IEC 61131-3 does not discuss this problem.
- For efficiency reasons, it is desirable to recompile only a minimum set of sources to create a new version of a resource, configuration or program after a change. For example, if only Program1 has been modified, other programs, or even other resources, that do not need the modified POU need not be recompiled.
- A Project Manager should therefore support
- -registration of newly created files (sources, error logs, interface descriptions), -import of files from different projects, -display of all existing POUs, -renaming and deletion of POUs, -an information structure that makes the structure of the project (calling hierarchy, dependencies) understandable to the user, -maintenance of all information (POUs, interfaces, calling hierarchy, binary files, etc.) that the rest of the programming system needs for creating a project.
- Some IEC 61131-3 programming systems store data in individual files (e.g. one file per POU) on the hard disk, while others use a database. Either way, project files should only be edited via the Project Manager. To increase efficiency when supplying data in response to requests (e.g. from the linker), some information can be pre-processed, so that it is not necessary to scan the entire file system for each request.

## Section 7 6

### Title

7.6 Test & Commissioning Functions

### Paragraph 1

The first stage of program development is typically performed on a PC, without a PLC. When the most important parts of the program have been completed, work is continued with the PLC in the target environment. The following are typical tasks performed at this commissioning stage:

### Commissioning Tasks

- Download of the entire project or individual POUs (after modifications) to the PLC,
- Upload of the project from the PLC to the PC,
- Modification of the program in the PLC (either in “RUN” or “STOP” mode),
- Starting and stopping the PLC,
- Display of variable values (status),
- Direct setting of I/Os or variables (forcing),
- Deactivation of the physical outputs of the PLC to prevent unsafe plant conditions during tests. Programs are executed and values are assigned to direct variables just as they would be in normal operation. Additional software or hardware ensure that physical outputs are not influenced by values written to the output variables.
- Retrieving PLC system data, communication and network information from the PLC,
- Program execution control (breakpoint, single step,...).

### Paragraph After List

These functions are implemented in different ways and to different degrees by individual programming systems. IEC 61131-3 does not stipulate any requirements with respect to these features.

### Subsection 7 6 1

#### Title

7.6.1 Program transfer

#### Paragraphs

- After a POU has been created with the editor and been checked for syntax, PLC specific code is created. This can take the form of machine code for direct execution by the PLC’s processor, or it could consist of instructions to be interpreted by the PLC. The programming system puts this object code together with the object code of other POUs to make a program (link procedure).
- All that remains to be done is:
- -Connect the executable code with a defined CONFIGURATION (task association), -Map the logical hardware addresses to the actual physical addresses of the PLC, -Assign parameters to the PLC’s operating system.
- These tasks can be performed by a tool called a System Configurator, or in some implementations the PLC’s operating system can do some of the work.
- The entire project now needs to be transferred to the PLC. A tool known as the Communication Manager establishes a physical and logical connection to the PLC (e.g. a proprietary protocol via USB interface or a fieldbus protocol). This tool performs some checks, which are partly invisible to the user. For example:
- -Has contact been successfully established with the PLC? -Does the PLC’s current state allow transfer of new programs? Or can the PLC be put into the correct state? -Is the PLC’s hardware configuration compatible with the requirements of the program? -Is the current user authorised to access this PLC? -Visualisation of the current state of communication.
- The program is then downloaded to the PLC, together with all the information needed to run it. The PLC program may now be started (cold restart).

### Subsection 7 6 2

#### Title

7.6.2 Online modification of a program

#### Paragraph 1

If it is necessary to modify blocks whilst the program is running (PLC in “RUN” mode), this can be done in various ways:

#### Modification Methods

- By changing the POU on the PC and compiling the whole program again with the programming system. Everything is then downloaded to the PLC. If this is to be done in “RUN” mode, a second memory area must be available and activated after the download is completed, as the download generally takes too long to suspend execution of the cyclic PLC program.
- By modifying the POU on the PC and downloading only the modified POU to the PLC. This requires a block management function to be available on the PLC, which will accept the new block and replace the old block with the new one after the download has been completed. As the old and new blocks usually differ in size, a “garbage collection” is required from time to time in order to be able to re-use memory space which would otherwise be wasted.
- By replacing only individual networks (SFC, LD, or FBD) or instructions (SFC, ST, and IL). This is only possible if other parts of the POU are not affected. E.g., jump labels in other networks must not move if the PLC operating system does not include jump label management.

### Subsection 7 6 3

#### Title

7.6.3 Remote control: Starting and stopping the PLC

#### Paragraphs

- The PLC hardware typically features a switch to start and stop the PLC. This can be remote-controlled from the programming system.
- IEC 61131-3 defines different start modes for a PLC (see Section 3.5.3):
- 1. Cold Restart. The PLC starts the program without memorising any variable values. This is the case, for example, after downloading the program to the PLC.
- 2. Warm Restart. Following a power outage, program execution is resumed at the point where it was interrupted (e.g. in the middle of an FB). All variables carrying the RETAIN attribute retain the value they had before the interruption, all other variables are reset to their initial value.
- 3. Warm restart at beginning of program. The values of all RETAIN variables are also retained and all other variables are re-initialised, but the program is restarted at the beginning. This takes place automatically if the interruption time exceeds a parameterised time limit.
- As a rule, the user can only initiate cold restarts, whereas warm restarts take place automatically after power recovery.
- Additional commissioning features are:
- -Stopping of the PLC, either with the current output values or with “safe” output values, -Deletion of memory areas, to prevent uncontrolled restarts, -Selection of special operating system modes, e.g. test mode, maximum cycle time, etc.

### Subsection 7 6 4

#### Title

7.6.4 Variable and program status

#### Paragraphs

- The most important test function for debugging and commissioning a PLC program is the monitoring of the status of variables (“flags”) and external I/Os. Ideally, values should be displayed in a user-selectable form, as shown in Example 7.8.
- Depending on the implementation in the PLC and/or the programming system, there are different methods of viewing the current data and execution flow:
- 1. Variable List: Display of a list of variables (a). The variables contained in the list are scanned in the PLC and their values continuously updated on the screen. This method is frequently used for monitoring values from different parts of the program. Structured variables can also be displayed showing the values of their individual members.
- 2. Variable Status: All variables of a specific code portion are displayed. In Example 7.8, the values of Var1, Var2, Var3 and Coil are displayed in a separate window (a) or directly within a graphic (b-e).
- 3. Program Status (also Power Flow). Instead of displaying the values of individual variables, the result of each operation is displayed (the Current Result, see Section 4.1.2) (f-i). In the graphical languages, this is done by drawing thick or thin lines to represent TRUE and FALSE for Boolean expressions or displaying numerical values beside each line. Intermediate value computation on the PC can serve to display values that are not immediately linked to variables (e.g. operator NOT; OR connection in LD).
- The quality of values provided will depend on the functionality, the speed and the synchronisation between the programming system and the PLC. Depending on the operating system and the hardware features available, the values on the PLC can be “collected” at different times:
- -Synchronously, -Asynchronously, -On change.
- Synchronous Status: Values are collected at the end of a program cycle. The values are all generated at the same point in the execution of the program, and are therefore consistent. This is also the time when variables mapped to I/O addresses are written to the outputs (update of the process image). A cyclic program will in most cases execute much faster than values can be retrieved by the programming system, so the values viewed with the programming system are only updated every n cycles.
- Asynchronous Status: The programming system constantly requests a new set of values for the specified variables (asynchronously to the cycle of the PLC program). The values are collected at the moment when the request is received. Each value is a snapshot of the respective memory location.
- Status on change: Values are only collected when they change (e.g. a signal edge). This requires special hardware (address monitoring) within the PLC.
- Advanced systems supply additional data analysis tools. These allow the behaviour of variable values to be visualised over time (logic analysis) as shown in Figure 7.4.

#### Figure 7 4

##### Src

https://storage.googleapis.com/generativeai-downloads/images/7.6%20Test%20%26%20Commissioning%20Functions%20271.jpg

##### Alt

Figure 7.4. Example of data analysis of two REAL variables and one BOOL variable

##### Title

Figure 7.4. Example of data analysis of two REAL variables and one BOOL variable

#### Paragraphs After Figure 7 4

- Visualisation in program graphics quickly reaches its limit when it comes to displaying arrays or complex structures and their values. Separate variable windows are better suited for this purpose.
- Values for display include variables as well as parameters of functions and function blocks.
- A facility that is not often implemented as yet is the visualisation of the data flow between individual POUs, as shown in Figure 7.5.

#### Figure 7 5

##### Src

https://storage.googleapis.com/generativeai-downloads/images/272%207%20Innovative%20PLC%20Programming%20Systems.jpg

##### Alt

Figure 7.5. Display of the calling hierarchy of the POUs together with the actual parameters during execution of the PLC program.

##### Title

Figure 7.5. Display of the calling hierarchy of the POUs together with the actual parameters during execution of the PLC program.

#### Paragraphs After Figure 7 5

- When requesting variables to be displayed, it is not sufficient to specify the name of the POU in which they occur. In the example shown in Figure 7.5, the name fun1 would not be sufficient to identify which variables to display, as this POU is called twice (Type1 and Type2) and will return different values depending on the call parameters.
- In the case of function blocks, it is not sufficient to specify the name of the POU, as the function block type may be instantiated more than once and, as a result, will have different instance data. Additional specification of the instance name is also not unambiguous because a function block type may be instantiated with the same instance name in different POUs so that several instances with the same name will be used.
- For unambiguous identification it is therefore necessary to specify the call path and, in the case of functions, even the call location.
- Additional difficulties arise from the fact that the local variables of functions only exist during execution of the function, and are otherwise undefined.

### Subsection 7 6 5

#### Title

7.6.5 Forcing

#### Paragraphs

- To test the behaviour of programs and plant it is helpful to be able to force variables to specific values.
- To simulate a specific plant condition for the program in order to test certain program parts, some variables are set to fixed values using the programming system, and the PLC is made to use these values instead of the actual values.
- As long as the PLC is kept in “forcing” mode by the programming system and with the parameters set as shown in Example 7.9, the program will always find the value Boolean 1 when reading %IX0.2, %IX0.6 or %IX0.14.
- Depending on the implementation in the PLC, the variables being forced are either set to the forced value only once at the beginning of every cycle and the program itself can overwrite them during the cycle, or they are kept to the forced value throughout the cycle (overwriting is prevented).

### Subsection 7 6 6

#### Title

7.6.6 Program test

#### Paragraphs

- Breakpoints and Single Step, functions well known from PC development environments, can also be used for debugging PLC programs:
- -Breakpoint Set/ Reset. The user specifies a location in the program where execution is to be interrupted and further instructions from the user awaited. Advanced systems support conditional breakpoints, e.g. “Break at line 20 of block FB4 if Function_1 has been called, Variable_X has been set and Function_2 has been reached.” As mentioned before, specifying the line number and POU or instance name is not always sufficient, but the location in the calling hierarchy should be specified, see Figure 7.5.
- -Single Step. After stopping at a breakpoint, the user can execute the following instructions or graphical elements one at a time.

### Subsection 7 6 7

#### Title

7.6.7 Testing Sequential Function Chart programs

#### Paragraphs

- Special features are required to test programs written in SFC. Depending on the system, the following features are available:
- -Setting/Resetting transitions, to force or prevent a transition to the next step. -Activation of steps or transitions, to begin execution of a POU at a specific location. -Permanent blocking of steps or transitions, to prevent them from being activated. -Reading and modifying system data that is relevant to SFC, e.g. step flags, step timers, etc.
- This is the equivalent of forcing at SFC level.

## Section 7 7

### Title

7.7 Data Blocks and Recipes

### Paragraphs

- A recipe, in PLC parlance, is a set of variable values, which can be replaced by a different one, to make the same PLC program behave differently. For example, in an automated process, only parameters like length, weight, or temperature need to be changed to produce a different product. Using recipes, such process data can be modified during operation.
- The replacement of one set of data by another can be performed by the program itself. In this case, all possible data sets have to be stored in PLC memory. Another possibility is to download a new data set to the PLC at a convenient point during operation, replacing an existing data set.
- Some PLC systems use Data Blocks (DB) for this purpose. A data block is accessible throughout the project (global) and consists of data items of specific data types.
- The data block number gives the program the base address of the data block that is currently active. The data items are accessed by an index (data word number). To switch to a different data block, only the base address of the new block has to be selected in order to activate it.
- Older (not IEC 61131-3-conformant) systems used data blocks also for (temporarily) storing their own local data.
- Common features of data blocks can be summarised as follows:
- -DBs can be downloaded and replaced separately like any other block, -DBs are globally accessible by any other block, -Exactly one DB is active at any one time, -DBs contain data type information about their data items.
- As the subject of data blocks has not been raised until this late stage of our book, it is only natural at this point to ask: “Where are the DBs in IEC 61131-3?”
- IEC 61131-3 does not discuss data blocks. Instead of activating one global data block to hold parameters and local information for a function block, instantiation of function blocks is used (see Chapter 2). Each instance of a FB is automatically assigned its own “local” data record. FBs can also access global data. IEC 61131-3 therefore fully covers the functionality of data blocks as a means of assigning parameters to function blocks and storing local data.
- However, unlike POUs, the instance data areas of FBs cannot be replaced or initialised separately. Sets of data such as recipes are either already included in the PLC program or replaced when the entire POU is replaced by a new one that contains the new data.
- Ways of implementing most of the features of DBs using the methods of IEC 61131-3 are outlined here.
- Data that belongs together is declared as a structure or an array. Like data blocks, these consist of a number of values, each having a data type. Such compound variables can be used as input or output parameters, local or global data. Data structures like this can also conveniently be used to implement recipes.
- Switching between different sets of data can be done in several ways:
- 1. The PLC is stopped and a complete new program with different data is downloaded to the PLC. This method requires the PC to be permanently connected to the PLC and the process under control must be able to tolerate such interruptions.
- 2. Individual blocks (POUs) are replaced. The POUs downloaded from the PC replace POUs with identical names in the PLC, but have different initial values for the variables contained or call different POUs. The PLC’s operating system must have a block management facility that allows replacement of individual blocks during operation.
- 3. Remote SCADA software is used to dynamically modify the (global) set of data.
- 4. All the sets of data required are contained within the PLC. The program invokes POUs with different sets of data or assigns its function blocks different parameter sets depending on the situation.
- Replacing POUs seems appropriate for POUs which mainly:
- -provide global data, -copy or initialise data.
- Global and external variables are a common way of supplying parameters to parts of a program, e.g. function blocks:

### Example 7 10

#### Code

Type Definition:
TYPE rec_struct:
STRUCT
par1:int;
par2:int;
...
END_STRUCT;
END_TYPE

Main Program:
PROGRAM main
VAR_GLOBAL
recipe:rec_struct;
END_VAR
VAR
rec1: rec_struct := ...;
rec2: rec_struct := ...;
Work1: Work;
END_VAR
...
IF Condition THEN
recipe := rec1;
ELSE
recipe := rec2;
END_IF;
Work1 ();
...

Using POU:
FUNCTION_BLOCK Work
VAR EXTERNAL
Recipe: rec_struct;
END_VAR
...
LD recipe.par1
...

#### Caption

Example 7.10. The main program contains different sets of data (rec1, rec2). The global structure recipe is assigned one of these depending on a specified condition. Other POUs simply access the global variable with a corresponding EXTERNAL declaration.

### Paragraphs After Example 7 10

- The disadvantage of using GLOBAL declarations is that all data sets have to be stored in the PLC all the time. Systems that support the configuration of global variables can avoid this problem by allowing a resource to be supplied with values for its global data by another resource or via access paths (VAR_ACCESS).
- Global data is inherently error-prone when programs have to be modified, as side effects could occur in all locations where the data is accessed. The IEC 1131-3 principle of object-oriented data is also violated by using global variables. To prevent this, call parameters could be used instead of the global variables in Example 7.10.

### Example 7 11

#### Code

Main Program:
PROGRAM main
VAR
rec1: rec_struct := ...;
rec2: rec_struct := ...;
Work1: Work;
END_VAR
...
IF Condition THEN
Work1 (rec1);
ELSE
Work1 (rec2);
END_IF;
...

Using POU:
FUNCTION_BLOCK Work
VAR_IN_OUT
recipe: rec_struct;
END_VAR
...
LD recipe.par1
...

#### Caption

Example 7.11. To avoid the side effects that are possible when using the method in Example 7.10, data sets rec1 and rec2 are passed as input/ output parameters (this only passes a pointer and avoids copying huge data structures).

## Section 7 8

### Title

7.8 FB Interconnection

### Subsection 7 8 1

#### Title

7.8.1 Data exchange and co-ordination of blocks in distributed systems

#### Paragraphs

- IEC 61131-3 defines PROGRAM blocks, which hierarchically call function blocks and functions, passing them parameters. Each PROGRAM (or certain function block instances) is assigned tasks. Communication between the tasks takes place using global variables or ACCESS variables.
- Distributed PLC systems, as used in industrial plants, power supply systems or building automation, require:
- -parallel, autonomous execution of individual algorithms, -geographically separate computing nodes, -asynchronous data exchange.
- Today, distributed applications are typically implemented as follows. Pre fabricated blocks are copied from a library to create a new project. Missing functionality is implemented in new, specially written blocks. One PROGRAM, together with the function blocks and functions called, constitutes an executable unit.
- Each PROGRAM is now assigned a node in the network (tasks of control units in the network), and the inputs and outputs of all programs are interconnected. Unconnected inputs of program instances are assigned individual parameter values where necessary. This is shown in Figure 7.8
- Libraries are usually implemented by experts from the hardware manufacturer or are part of the firmware (EPROM) of the PLC or network node.
- This is an extreme case of the IEC 61131-3 programming model. The application is “configured” from pre-fabricated blocks. The programs run mostly autonomously without being “called” by other blocks. Functions and function blocks in the sense of IEC 61131-3 are provided locally to be called by the PROGRAM. A direct call to a block in another node or CPU is not possible (a PROGRAM may not invoke a PROGRAM).

#### Figure 7 8

##### Src

https://storage.googleapis.com/generativeai-downloads/images/280%207%20Innovative%20PLC%20Programming%20Systems.jpg

##### Alt

Figure 7.8. Assignment of blocks to network nodes and PLC tasks. All PROGRAMs run independently and are connected only via ACCESS variables.

##### Title

Figure 7.8. Assignment of blocks to network nodes and PLC tasks. All PROGRAMs run independently and are connected only via ACCESS variables.

#### Paragraphs After Figure 7 8

- It is possible to deviate from the definition in IEC 61131-3, which stipulates that only programs may be connected to objects in different tasks. Function blocks can then be distributed amongst computing nodes (tasks) and interconnected at will. This allows a much closer mapping of algorithms to network nodes. The performance of a distributed automation system can be increased without changing the program by simply adding computing nodes and re-configuring appropriately.
- This involves two problems, as shown in Figure 7.8:
- 1. The run-time behaviour of all blocks must be properly co-ordinated because control information sent together with other data information is confusing.
- 2. A mechanism is needed to ensure consistent flow of data between blocks (network nodes) by checking the validity of data items or groups of data items.
- As long as all blocks interconnected are executed on the same network node, execution control can be implemented implicitly (blocks are activated from top to bottom or from left to right, according to the function block network) or explicitly configured (execution number for every block). Additional control is needed if the tasks involved have no common time base, e.g. if they are executed on different nodes in the network.

### Subsection 7 8 2

#### Title

7.8.2 Macro techniques in FB interconnection

#### Paragraphs

- A project with interconnections as described in Section 7.8.1 consists of a large number of blocks. To make the structure easier to understand, groups of blocks can be visually combined and shown as one block. Related functionality can be grouped onto separate working sheets, called Function Charts. This “macro” technique is explained below. Example 7.12 gives an example from the plant industry.

#### Example 7 12

##### Src

https://storage.googleapis.com/generativeai-downloads/images/7.8%20FB%20Interconnection%20281.jpg

##### Alt

Example 7.12. Interconnection of simple basic elements in plant engineering

##### Title

Example 7.12. Interconnection of simple basic elements in plant engineering

#### Paragraph After Example 7 12

Placing and connection of blocks (Get_Current_Value, CheckConsistency, ...) is performed graphically by the user. All blocks have a clearly defined functionality. Data declarations are made implicitly by block instantiation. Only when connecting inputs and outputs does the user (or programming system) have to check for compatibility of data types.
Blocks provided by the manufacturer can be used to build more sophisticated blocks using a kind of macro technique. This corresponds to building complex data structures out of elementary data types. For this reason these blocks are sometimes called Derived Function Blocks.

#### Example 7 13

##### Src

https://storage.googleapis.com/generativeai-downloads/images/282%207%20Innovative%20PLC%20Programming%20Systems.jpg

##### Alt

Example 7.13. The blocks from Example 7.12 (called Temp_Check) attain a higher degree of specialisation and sophistication when grouped together using macro techniques.

##### Title

Example 7.13. The blocks from Example 7.12 (called Temp_Check) attain a higher degree of specialisation and sophistication when grouped together using macro techniques.

#### Paragraphs After Example 7 13

- After definition as shown in Example 7.13, block Temp_Control can be used in applications.
- If the blocks used are elementary blocks defined by the manufacturer (well-known behaviour), good simulation results can be achieved (e.g. run-time, effects of different hardware assignments or modifications in communication infrastructure).

## Section 7 9

### Title

7.9 Diagnostics, Error Detection and Error Handling

### Paragraphs

- Diagnostics is basically the “detection of error conditions during operation and localisation of the source of error”. There are four areas where errors can occur:
- 1. PLC hardware, including connections to other devices, 2) PLC software (operating system), 3) User software, 4) Process behaviour: the process under control may enter an unforeseen state.
- A general distinction is made between system errors and programming errors.
- Vendors offer various tools for diagnostics. These can be either additional hardware that checks for error conditions and provides information about them, or software functions to be included in the application. SFC is a good language for detecting errors in a running installation (e.g. “Transition XY not firing”) or for continuing with a defined response after detecting an error.

### Error Concept Iec

#### Title

Error concept of IEC 61131-3.

#### Paragraphs

- IEC 61131-3 has only a very general approach to error handling, giving the user a certain amount of support in handling cases 2) and 3) above. The standard requires an error list to be provided by PLC manufacturers, indicating the system response to a variety of specified error conditions (see Appendix E):
- 1. The error is not reported. There must be a statement to this effect in the user documentation.
- 2. The possibility that the error might occur is detected when preparing (editing, compiling or loading) the program and the user is warned accordingly.
- 3. The error is reported during execution of the program (at run time). Manufacturer-dependent procedures for handling the error are provided.
- Quality assurance plays an important role in the automation business. The quality of today’s compilers effectively prevents some typical program errors from slipping through at the compilation stage. Concepts of IEC 61131-3, like strict data type checking, even prevent some errors from occurring in the first place, during programming. However, some errors can only be detected at run time.
- Some error situations, like division by zero (see Appendix E) should be checked by the PLC system. IEC 61131-4 (with supporting information for programmers [IEC 61131-4]) recommends the definition of a uniform global (manufacturer dependent) data structure for errors, which should contain the status of an operation (Error Yes/ No), the type of error (Division by zero) and the location of the error (POU name). This information could then be scanned by the application, or connected to the SINGLE input of a task (see Section 6.3.4). This task would be connected to a system routine or application routine for specific error handling to initiate online correction, an error message to the user, a warm restart or similar.
- In the event of an error, the PLC system would set the error status to TRUE and set other members of the data structure accordingly, thus starting the error task.

### Extended Error Handling

#### Title

Extended error handling model (beyond IEC).

#### Paragraphs

- To improve software quality, it is desirable to provide the users themselves with a means of defining error conditions in a standardised form. A language construct like “asserted conditions” could be used for this. In this case, the programmer would implement the application with checks.
- For example:
- -Is the value of a variable within the limits that apply at this program location? -Do two variables match?
- Such assertions can be simple expressions for the Current Result (CR) in IL, as shown in Example 7.14. Assertions can be used to check “critical” values at run time. Complex expressions can also be employed -at specified program locations -to compare input and output values, check for consistency or check important process parameters for logical relations.
- Some systems provide automatic error checking facilities, e.g. for array indices, i.e. the index in an array must not be above the upper or below the lower limit of the array. This is supported by IEC 61131-3, see Chapter 3.
- The response in the event of a violation of an assertion must be configurable, e.g.: Stop program; issue error message to visualisation system. For more sophisticated “exception handling”, multiple error routines (user-defined or standard error POUs) should be assignable to different assertions. These routines should have special privileges, such as the right to stop or restart the PLC system.
- At present, assertion conditions and the associated error responses (without special privileges) still have to be written by users themselves, which is not always an ideal solution from the point of view of program readability.

## Section 7 10

### Title

7.10 Hardware Dependence

### Paragraphs

- The architecture of error handling is evident throughout a program, and is at present dependent on the manufacturer. The lack of standardised error detection and error handling routines makes porting of applications between different systems difficult, requiring specially trained system experts.
- Studies have shown that even sophisticated cross-compilers can rarely automatically cross-compile more than 60% of a non-IEC 61131-3 PLC application to an IEC 61131-3 programming system. The reason is that the programs are heavily hardware-dependent. Custom routines are used to control special hardware, or specialised hardware addresses (status registers, system memory,...) are accessed.
- IEC 61131-3 does not set out to eliminate the individuality of manufacturers. After all, a wide variety of software and hardware ensures high functionality. To ease portability, IEC 61131-3 provides the following mechanisms:
- -All external information a program needs should be provided by IEC 61131-3- conformant global variables, access paths or communication FBs (see IEC 61131-5).
- -Hardware I/O addresses used have to be declared in the PROGRAM or configuration scope.
- -Hardware-dependent features have to be listed in a special table that manufacturers have to provide with their software.
- The list of implementation-dependent parameters is given in Appendix F.
