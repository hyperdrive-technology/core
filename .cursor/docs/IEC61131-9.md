# Chapter 9

## Title

9 Programming by Configuring with IEC 61499

## Introduction

- Programming using graphical elements taken from the “real world” of the application to be programmed is becoming more and more important.
- With the graphical languages LD, FBD or SFC of IEC 61131-3 previously discussed, data flow and logical execution sequence can be programmed and documented using symbols and names. However, it is also desirable to be able to display the topological distribution of programs, their general configuration and interconnections to other parts of a distributed automation project in a graphical manner. This takes place at a higher, more abstract level than the programming of POUs described so far.
- The tools for configuring complex and distributed applications are called configuration editors. Program parts, such as function blocks, are combined to form larger units. This is done by interconnection of function blocks.
- In order to standardise unified language elements for this purpose, international standard IEC 61499 was defined. It can be considered both a separate standard and a supplement to the existing IEC 61131.This chapter gives a summary of the basic concepts and ideas of this additional standard and explains its relationship with IEC 61131.The subject of standard IEC 61499 would need to be discussed in greater detail in another book, see also [IEC 61499-1], [IEC 61499-2] and [IEC 61499-4].

## Section 9 1

### Title

9.1 Programming by FB Interconnection with IEC 61131-3

### Paragraphs

- In order to clarify the differences between IEC 61499 and IEC 61131-3, we shall first look at some special features of distributed programming.
- The programming languages described in Chapter 4 are used to define algorithms for blocks. Function blocks and functions call each other, exchange information by means of their parameters and form a program in conjunction with a POU of type PROGRAM. A program runs as a task on a resource (CPU of a PLC).
- IEC 61131-3 essentially concentrates on describing single programs together with their execution conditions. Information exchange between programs takes place using ACCESS variables or global data areas. This topic is discussed in Section 7.8 and illustrated by Figure 7.8.
- Complex, distributed automation tasks have an extensive communication and execution structure. Intensive data exchange takes place between geographically separate control units. The semantic and temporal dependencies and conditions have to be specified.
- To do this, programs are assigned to tasks of network nodes, execution conditions are defined as described in Section 6.1, and the inputs and outputs of programs (such as network addresses or parameter values) are interconnected.
- Creating distributed automation solutions, i.e. configuring function blocks for physically different and geographically separate hardware and synchronising their execution, is the subject of standard IEC 61499.Although the concept emphasises the distribution to several automation devices, it may also be helpful to run an IEC 61499 application on a single control unit.

## Section 9 2

### Title

9.2 IEC 61499 – The Programming Standard for Distributed PLC Systems

### Paragraphs

- The sequential invocation of blocks defined in IEC 61131-3 is not a suitable method for program structuring in distributed systems. This is already apparent in Figure 7.8. The goal of a distributed, decentralised system is to distribute programs between several control units and to execute them in parallel (in contrast to sequential execution with invocation by CAL). Here it is essential to ensure data consistency between nodes of the networked system, i.e. to define exact times for mutual data exchange.
- Two kinds of information exchange play an essential part in IEC 61499:
- 1. Data flow of user data, 2) Control flow, which controls the validity of user data as event information.
- The interaction of data and control flow can also be programmed by means of IEC 61131-3 using global variables and access paths. But the resulting overall program can easily become hard to read and slower to execute.
- In order to describe the interactions between program parts and elements of control hardware within a distributed, networked automation system easily and exactly, IEC 61499 uses a model (“top-down” approach) with several hierarchical levels:
- -System -Application -Device -Function block -Resource
- The definitions of the terms Resource and Function Block are, however, wider than those of IEC 61131-3, as will be explained in this chapter.
- Instead of assigning PROGRAM and TASK to a resource, function blocks in IEC 61499 can be assigned run-time properties directly via the resource .

### Subsection 9 2 1

#### Title

9.2.1 System model

#### Paragraph 1

In a real automation environment several control units, referred to here as devices, execute the same or different applications in parallel. This is outlined in Figure 9.1.

#### Figure 9 1

##### Src

https://storage.googleapis.com/generativeai-downloads/images/9.2%20IEC%2061499%20%E2%80%93%20The%20Programming%20Standard%20for%20Distributed%20PLC%20Systems%20295.jpg

##### Alt

Figure 9.1. Control of a real process can be distributed between several devices. As in IEC 61131-3, several programs can also be configured for one device. The program parts interchange information via communication networks.

##### Title

Figure 9.1. Control of a real process can be distributed between several devices. As in IEC 61131-3, several programs can also be configured for one device. The program parts interchange information via communication networks.

### Subsection 9 2 2

#### Title

9.2.2 Device model

#### Paragraphs

- Closer examination of a device, as in Figure 9.2, shows that it consists of:
- -its application programs, -an interface to the communication network, -an interface to the automation process, -the device hardware, on which the resources run.
- A resource represents an independent executable unit with parameters (a task in the general sense). Several resources can run on each device, and they can perform the same or different applications.
- IEC 61499 uses two views of a distributed program, which are explained in this chapter. On the one hand, this standard looks at the hierarchy of System— Device—Resource, in order to describe system structure and the corresponding run-time properties. On the other hand, it also defines the user-oriented view of a distributed program. This user view is summarised by application and function block models that are discussed later in this chapter.

#### Figure 9 2

##### Src

https://storage.googleapis.com/generativeai-downloads/images/296%209%20Programming%20by%20Configuring%20with%20IEC%2061499.jpg

##### Alt

Figure 9.2. A device can contain several resources, which use common interfaces to exchange information with other control units and the automation process.

##### Title

Figure 9.2. A device can contain several resources, which use common interfaces to exchange information with other control units and the automation process.

### Subsection 9 2 3

#### Title

9.2.3 Resource model

#### Paragraph 1

A resource consists of function blocks, which exchange event and data information using special interfaces. There are two kinds of function blocks:

#### Fb Types

- 1. Service interface function blocks, which are standard FBs and form the interfaces to the automation process and the communication network.
- 2. User-defined function blocks, which make up the actual application program (algorithm).

#### Paragraphs After List

- As in IEC 61131-3, there is a distinction between FB type and FB instance.
- Run-time properties, such as the maximum number of instances, execution time, number of connections etc., can be assigned to each function block within the resource.
- The interconnection of FBs by the user is not carried out at resource level, but at application level (see next section). The real information exchange between the FBs of the application program takes place “invisibly” for the user via the communication and process interfaces.
- An application can be implemented on one or more resources.

### Subsection 9 2 4

#### Title

9.2.4 Application model

#### Paragraph 1

This section deals with the user-oriented view of a program. This view corresponds to the horizontal, grey “Application” bar in Figure 9.3, which can extend over several devices or resources.

#### Figure 9 3

##### Src

https://storage.googleapis.com/generativeai-downloads/images/9.2%20IEC%2061499%20%E2%80%93%20The%20Programming%20Standard%20for%20Distributed%20PLC%20Systems%20297.jpg

##### Alt

Figure 9.3. A resource consists of function blocks for controlling and data processing (algorithms) together with interface blocks (communication/process).

##### Title

Figure 9.3. A resource consists of function blocks for controlling and data processing (algorithms) together with interface blocks (communication/process).

#### Paragraph After Figure 9 3

The application level forms the real programming level because it is here that the FBs are interconnected with one another, independently of the resources on which they run. It describes the application – which may subsequently be distributed amongst several resources.
After the application program, consisting of several FBs, has been assigned to the resources and the program has been started, communication takes place implicitly or explicitly (depending on the vendor) via the service interfaces with the connections specified by the user.

#### Figure 9 4

##### Src

https://storage.googleapis.com/generativeai-downloads/images/298%209%20Programming%20by%20Configuring%20with%20IEC%2061499.jpg

##### Alt

Figure 9.4. The application consists of interconnected function blocks; each of which has both controlling (control flow) and data processing (data flow) functions.

##### Title

Figure 9.4. The application consists of interconnected function blocks; each of which has both controlling (control flow) and data processing (data flow) functions.

#### Paragraph After Figure 9 4

Control and data information always flows into a function block from the left and is passed on after processing from the outputs on the right.

### Subsection 9 2 5

#### Title

9.2.5 Function block model

#### Paragraphs

- The function blocks are the smallest program units (like POUs). Unlike the FBs of IEC 61131-3, a function block in IEC 61499 generally consists of two parts:
- 1. Execution control: Creation and processing of events with control inputs and outputs (control flow),
- 2. Algorithm with data inputs and outputs and internal data (data flow and processing).
- These function blocks can be specified in textual or graphical form. Function blocks are instantiated for programming, as in IEC 61131-3. The language elements for FB interface description are therefore very similar, see also Chapter 2.
- Figure 9.5 shows the graphical representation of a function block in accordance with IEC 61499.

#### Figure 9 5

##### Src

https://storage.googleapis.com/generativeai-downloads/images/9.2%20IEC%2061499%20%E2%80%93%20The%20Programming%20Standard%20for%20Distributed%20PLC%20Systems%20299.jpg

##### Alt

Figure 9.5. Graphical representation of a function block. Details of execution control, the internal algorithm and internal data are not shown at this level.

##### Title

Figure 9.5. Graphical representation of a function block. Details of execution control, the internal algorithm and internal data are not shown at this level.

#### Paragraphs After Figure 9 5

- The algorithm part is programmed in IEC 61131-3 (like a POU body).
- The execution control part is programmed using a state diagram or sequential function chart (SFC in IEC 61131-3). The events are input values for state diagrams, or execution control charts (ECC) . These ECCs control the execution times of the algorithm or parts of it depending on the actual state and incoming events.

#### Example 9 1

##### Src

https://storage.googleapis.com/generativeai-downloads/images/9.2%20IEC%2061499%20%E2%80%93%20The%20Programming%20Standard%20for%20Distributed%20PLC%20Systems%20299.jpg

##### Alt

Example 9.1. Function block with typed formal parameters and state diagram (ECC)

##### Title

Example 9.1. Function block with typed formal parameters and state diagram (ECC)

#### Example 9 2

##### Src

https://storage.googleapis.com/generativeai-downloads/images/300%209%20Programming%20by%20Configuring%20with%20IEC%2061499.jpg

##### Alt

Example 9.2. Execution control of Example 9.1 using Sequential Function Chart (SFC) as defined in IEC 61131-3. The output events CNF and INITO are set by the application program and controlled by calling standard function blocks.

##### Title

Example 9.2. Execution control of Example 9.1 using Sequential Function Chart (SFC) as defined in IEC 61131-3. The output events CNF and INITO are set by the application program and controlled by calling standard function blocks.

#### Paragraphs After Example 9 2

- Example 9.1 contains function block SEL_Counter (instance name Selection&Counter), which consists of an ECC control part and the algorithm part, which in turn consists of the two algorithms INIT and MAIN. The execution control determines which algorithm part will be active at what time.
- In Example 9.1, when the event INITI occurs, the FB control will change from initial state START to state INIT_STATE and algorithm INIT will be executed. Afterwards event output variable INITO is set (action “N”), followed by a RESET (i.e. a signal pulse). Now execution control evaluates the next transition. This has the constant parameter “1” in this example, which means the condition is always true, and leads back to state START. Incoming event REQ is processed analogously.
- This behaviour is equivalent to the actions of Sequential Function Chart (SFC) in IEC 61131-3 and is illustrated by Example 9.2. IEC 61499 assumes that it is more favourable to specify the execution control using state diagrams, as with this method only one state can be active at a time. In SFC this can be achieved by prohibiting simultaneous branches.
- Example 9.3 shows the textual definition of the FB type in Example 9.1.
- The keyword WITH connects an event input/output with a data input/output. If an event parameter is set, it indicates the validity of the corresponding data line (assigned by WITH).

#### Example 9 3

##### Code

FUNCTION_BLOCK SEL_Counter
EVENT_INPUT
INITI WITH START;
REQ WITH G, IN0, IN1;
END_EVENT
EVENT_OUTPUT
INITO WITH COUNT;
CNF WITH SEL_OUT, COUNT;
END_EVENT
VAR_INPUT
START: UINT;
G: BOOL;
IN0, IN1: INT;
END_VAR
VAR_OUTPUT
SEL_OUT: INT;
COUNT: UINT;
END_VAR
VAR
INTERNAL_COUNT: UINT;
END_VAR
...
ALGORITHM INIT:
INTERNAL_COUNT := START;
COUNT := INTERNAL_COUNT;
END_ALGORITHM
ALGORITHM MAIN:
IF G = 0 THEN SEL_OUT := IN0;
ELSE
SEL_OUT := IN1;
END_IF;
INTERNAL_COUNT :=
INTERNAL_COUNT +1;
COUNT := INTERNAL_COUNT;
END_ALGORITHM
END_FUNCTION_BLOCK

##### Caption

Example. 9.3. Example 9.1 in textual representation (Structured Text ST of IEC 61131-3).

#### Composite Function Blocks

##### Title

Composite function blocks

##### Paragraphs

- For the purposes of clear, object-oriented representation, several basic function blocks can be combined to form a new composite function block, which looks just like a “normal” function block on the outside, as shown in Figure 9.6.
- Composite function blocks do not have their own execution control part, as this is the sum of the controls of all basic FBs of which it is composed. In the graphical representation in Figure 9.6 a) the FB header is therefore “empty”.

##### Figure 9 6

###### Src

https://storage.googleapis.com/generativeai-downloads/images/302%209%20Programming%20by%20Configuring%20with%20IEC%2061499.jpg

###### Alt

Figure 9.6. A composite function block consists of several interconnected function blocks with a common interface. a) Example: Internal structure of a composite FB, b) Example: External appearance of this FB.

###### Title

Figure 9.6. A composite function block consists of several interconnected function blocks with a common interface.
a) Example: Internal structure of a composite FB,
b) Example: External appearance of this FB.

### Subsection 9 2 6

#### Title

9.2.6 Creating an application

#### Paragraphs

- IEC 61499 application programmers write programs by configuring and assigning parameters to ready-made function blocks.

#### Table 9 1

| FB               | Explanation                                                                                                                                                               |
| ---------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Standard FBs     | • FBs with functionality as in IEC 61131-3<br>• Service interface FBs (standardised communication services)<br>• Event FBs (standardised event generation and processing) |
| User-defined FBs | Algorithms and ECC execution control e.g. programmed with IEC 61131-3                                                                                                     |

#### Caption Table 9 1

Table 9.1. Different types of function blocks in IEC 61499

#### Paragraphs After Table 9 1

- The function blocks in Table 9.1 can be implemented as basic or composite FBs with a uniform interface.
- For example, Event FBs provide functions for merging and splitting events or creating single or cyclic events.
- A configuration editor is used for allocating blocks to resources (devices) and for interconnecting FBs.

## Section 9 3

### Title

9.3 Overview of the Parts of IEC 61499

### Paragraphs

- The standard IEC 61499 consists of three parts, whose main contents are summarised in Table 9.2 ([IEC 61499-1 to -4]) (as of May 2008). A revised version of this standard is envisaged for 2010.

### Table 9 2

| Parts                            | Contents                                                                                                                                                  |
| -------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. Architecture                  | Introduction and modelling, describes the validity, defines common terms, specification of function blocks, service interfaces, configuration and syntax. |
| 2. Software Tool Requirements    | Contains descriptions to support the life cycle of distributed programs. This document is still in the design phase.                                      |
| 3. Rules for Compliance Profiles | Describes rules for checking the compatibility of user programs with the standard, similarly to IEC 61131-3.                                              |

### Caption Table 9 2

Table 9.2. Structure and contents of standard IEC 61499
