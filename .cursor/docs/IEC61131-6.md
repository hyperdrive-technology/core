# Chapter 6

## Title

6 State-of-the-Art PLC Configuration

## Introduction

- IEC 61131-3 takes advantage of recent advances in technology by incorporating modern concepts that allow the modelling of PLC projects consisting of more than just single-processor applications.
- The software model of IEC 61131-3 allows for practice-oriented structuring (modularization) of applications into units (POUs). This eases maintenance and documentation, and improves the diagnostics facilities for PLC programs.
- A uniform software architecture is essential for the portability of applications. The resources of PLCs are given explicit run-time properties, thus building a platform for hardware-independent programs.
- In the traditional method of structuring PLC projects (see Figure 2.5), applications are modularised into blocks, and certain types of blocks (e.g. organisation blocks) have implicit run-time properties. IEC 61131-3 provides more sophisticated and standardised means of accomplishing this.
- This chapter explains the configuration elements of IEC 61131-3, which are an important means of structuring applications and defining the interaction of POUs. Configuration elements describe the run-time properties of programs, communication paths and the assignment to PLC hardware.
- IEC 61131-3 configuration elements support the use of today’s sophisticated operating systems for PLCs. The CPU of a typical PLC today can run multiple programs at the same time (multitasking).

## Section 6 1

### Title

6.1 Structuring Projects with Configuration Elements

### Paragraph 1

The preceding chapters have discussed the programming and usage of POUs. This section gives an overview of the modelling and structuring of PLC applications at a higher level.

## Section 6 2

### Title

6.2 Elements of a Real-World PLC Configuration

### Paragraph 1

Configuration elements match the elements found in real-world PLC systems:

### Elements List

- Configuration: A PLC system, e.g. a controller in a rack with multiple (interconnected) CPUs, controlling a cell of machines
- Resource: One CPU in a PLC, possibly capable of multitasking
- Task: Run-time properties for programs and function blocks (“type” of PLC program)
- Run-time program: Unit consisting of a PROGRAM or FUNCTION_BLOCK and the TASK associated with it

### Paragraphs After List

- The main programs of a CPU are made up of POUs of type PROGRAM. Larger applications tend to be structured in Sequential Function Chart, controlling the execution of the other POUs.
- Main programs and function blocks are assigned run-time properties, like “cyclic execution” or “priority level”, as indicated in Figure 6.2.
- The term “run-time program” denotes the unit consisting of all the necessary POUs and the TASK, i.e. a program together with its run-time properties. A run time program is therefore a self-contained unit capable of running independently in a CPU.
- Figure 6.2 shows the relation between configuration elements and the components of real-world PLC systems (see also Figure 2.4):

### Figure 6 2

#### Src

https://storage.googleapis.com/generativeai-downloads/images/236%206%20State-of-the-Art%20PLC%20Configuration.jpg

#### Alt

Figure 6.2. A real-world configuration. ProgA and TaskB are linked to form a run-time program and assigned to a CPU resource in a PLC system

#### Title

Figure 6.2. A real-world configuration. ProgA and TaskB are linked to form a run-time program and assigned to a CPU resource in a PLC system

### Paragraphs After Figure 6 2

- The actual assignment of configuration elements to the elements of a PLC system will depend on the hardware architecture.
- Using configuration elements, all tasks can be assigned to one CPU which will execute them simultaneously, or they can be assigned to different CPUs.
- Whether a RESOURCE is to be regarded as one CPU or a group of CPUs contained in one rack therefore depends on the concrete PLC hardware architecture.
- For small PLC systems, all configuration can be done in one POU of type PROGRAM: programs can declare global variables and access paths, and directly represented variables. The definition of run-time properties, CPU assignment, etc. can be performed implicitly by features of the programming system or PLC. This corresponds to the traditional approach for programming PLCs.
- This capability of PROGRAM POUs facilitates gradual migration from existing applications to IEC 61131-3-compliant programs.

## Section 6 3

### Title

6.3 Configuration Elements

### Paragraph 1

We will first give an overview of the configuration elements, and then explain them in more detail. We will refer to the example in Section 6.4.

### Subsection 6 3 1

#### Title

6.3.1 Definitions

#### Paragraph 1

The functions of the configuration elements are as follows:

#### Table 6 1

| Configuration Element | Description                                                                                                                                                                                                                                         |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Configuration         | - Definition of global variables (valid within this configuration)<br>- Combination of all resources of a PLC system<br>- Definition of access paths between configurations<br>- Declaration of directly represented (global) variables             |
| Resource              | - Definition of global variables (valid within this resource)<br>- Assignment of tasks and programs to a resource<br>- Invocation of run-time programs with input and output parameters<br>- Declaration of directly represented (global) variables |
| Task                  | - Definition of run-time properties                                                                                                                                                                                                                 |
| Run-time program      | - Assignment of run-time properties to a PROGRAM or FUNCTION_BLOCK                                                                                                                                                                                  |

#### Caption Table 6 1

Table 6.1. Definition of configuration elements. Directly represented global variables and access paths can also be defined within a PROGRAM.

#### Paragraphs After Table 6 1

- Declaration of directly represented variables maps the entire configuration to the hardware addresses of the PLC. These declarations can be made with VAR_GLOBAL at the configuration, resource or PROGRAM level. POUs can access these via VAR_EXTERNAL declarations.
- When put together, the declarations of directly represented variables for all POUs make up the allocation table of a PLC application. Rewiring, i.e. re assigning symbolic addresses to absolute PLC addresses, can be carried out by simply modifying this list.
- Configuration elements are typically declared in textual form. The standard provides a definition for a graphical representation of a TASK, but the graphical representation of all other configuration elements is left to the programming system and is therefore implementation-dependent.

### Subsection 6 3 2

#### Title

6.3.2 The CONFIGURATION

#### Paragraph 1

IEC 61131-3 uses the Configuration (CONFIGURATION) to group together all the resources (RESOURCE) of a PLC system and provide them with means for data exchange. A configuration consists of the elements shown in Figure 6.3.

#### Figure 6 3

##### Code

CONFIGURATION Configuration name
Type definitions
Global declarations
RESOURCE declarations
ACCESS declarations
END_CONFIGURATION

##### Caption

Figure 6.3. Structure of a CONFIGURATION declaration

#### Paragraphs After Figure 6 3

- Within a configuration, type definitions with global validity for the entire PLC project can be made. This is not possible in other configuration elements.
- Communication between configurations takes place via access paths defined with VAR_ACCESS. Variables defined with VAR_GLOBAL are valid only within one configuration, and are accessible to all resources, programs and function blocks of that configuration. VAR_EXTERNAL cannot be used at the configuration level.
- Communication blocks for communication between configurations are defined in part 5 of IEC 61131 (see also Section 6.5).

#### Example 6 1

##### Code

CONFIGURATION PLC_Cell1
VAR_GLOBAL ... END_VAR
RESOURCE CPU_Conveyor ON CPU_001 ... END_RESOURCE
RESOURCE CPU_Hammer ON CPU_002... END_RESOURCE
VAR_ACCESS ... END_VAR
END_CONFIGURATION

##### Caption

Example 6.1. Elements of the CONFIGURATION in Example 6.6

#### Paragraph After Example 6 1

Example 6.1 shows part of the declaration of a configuration named PLC_Cell1.
It contains a section with global variables, which are not visible to other configurations, but only accessible from resources CPU_Conveyor and CPU_Hammer and all POUs executing on them.
VAR_ACCESS is used for exchanging data between the resources of the same configuration or different configurations (access paths)
Configurations and resources do not contain instructions like POUs, but solely define the relations between their elements.

### Subsection 6 3 3

#### Title

6.3.3 The RESOURCE

#### Paragraph 1

A Resource is defined in order to assign TASKs to the physical resources of a PLC system. A resource consists of the elements shown in Figure 6.4.

#### Figure 6 4

##### Code

RESOURCE Resource name ON Resource
Global declarations
TASK declarations
END_RESOURCE

##### Caption

Figure 6.4. Structure of a resource declaration

#### Paragraphs After Figure 6 4

- The resource name assigns a symbolic name to a CPU in a PLC. The types and numbers of the resources in a PLC system (individual CPU designations) are provided by the programming system and checked to ensure that they are used correctly.
- Global variables, which are permissible at resource level, can be used for managing the data that are restricted to one CPU.

#### Example 6 2

##### Code

RESOURCE CPU_Conveyor ON CPU_001
TASK ...
PROGRAM ... WITH ...
END_RESOURCE
RESOURCE CPU_Hammer ON CPU_002
VAR_GLOBAL ... END_VAR
TASK ...
PROGRAM ... WITH ...
END_RESOURCE

##### Caption

Example 6.2. Elements of the resources in Example 6.6 (Detail from Example 6.1)

#### Paragraphs After Example 6 2

- Example 6.2 shows part of the declaration of two resources. The global data declared for resource CPU_002 cannot be accessed from resource CPU_001.
- The keyword PROGRAM has a different meaning within a resource definition than it has at the beginning of a POU of type PROGRAM!
- Within a resource declaration, the keywords PROGRAM ... WITH are used to link a task to a POU of type PROGRAM.

### Subsection 6 3 4

#### Title

6.3.4 The TASK with run-time program

#### Paragraphs

- The purpose of a TASK definition is to specify the run-time properties of programs and their FBs.
- The normal practice with PLC systems hitherto has been to use special types of blocks (e.g. organisation blocks, OBs), with implicit, pre-defined run-time properties. For example, they can be used to implement cyclic execution, or to make use of properties of the PLC system for interrupt handling or error responses.
- A TASK definition according to IEC 61131-3 enables these program features to be formulated explicitly and vendor-independently. This makes program documentation and maintenance easier.
- Figure 6.5 shows the structure of a textual TASK declaration:

#### Figure 6 5

##### Code

TASK Task_name (Task properties)
PROGRAM Program_name WITH Task_name : (PROGRAM interface)

##### Caption

Figure 6.5. Structure of a textual declaration of a run-time program, defining a task and associating the task with a PROGRAM. The task properties give the parameter values of the task, the PROGRAM interface gives the actual parameters for the formal parameters.

#### Paragraph After Figure 6 5

The association of a TASK with a PROGRAM defines a run-time program with the name Program_name. This is the instance name of the program of which the calling interface is given in the declaration. This interface includes input and output parameters of the POU of type PROGRAM and is initialised when starting the resource.
One PROGRAM can be executed in multiple instances (run-time programs) using such declarations.
A task can be defined textually, as shown above, or graphically, as shown in Figure 6.6. The task properties are shown as inputs to a box, but the graphical representation of the association with a program (PROGRAM...WITH...) is not defined by IEC 61131-3.

#### Figure 6 6

##### Src

https://storage.googleapis.com/generativeai-downloads/images/6.3%20Configuration%20Elements%20241.jpg

##### Alt

Figure 6.6. Graphical declaration of a task. Left: General form. Centre and right: Two tasks from Example 6.6

##### Title

Figure 6.6. Graphical declaration of a task. Left: General form. Centre and right: Two tasks from Example 6.6

#### Paragraph After Figure 6 6

The input parameters for tasks shown in Table 6.2 are used for specifying the task properties.

#### Table 6 2

| TASK Parameter | Meaning                                                                                                                                                                                                                                                                                                                |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SINGLE         | On a rising edge at this input, programs associated with the TASK will be called and executed once.                                                                                                                                                                                                                    |
| INTERVAL       | If a time value different from zero is supplied, all programs associated with the TASK will be executed cyclically (periodically). The value supplied is the interval between two invocations. This value can thus be used to set and monitor cycle time. If the input value is zero, the programs will not be called. |
| PRIORITY       | This input defines the priority of the associated programs compared to other programs running concurrently (multitasking). The meaning is implementation-dependent (see text below).                                                                                                                                   |

#### Caption Table 6 2

Table 6.2. TASK properties as input parameters

#### Paragraphs After Table 6 2

- The meaning of the PRIORITY input will depend on how concurrency of multiple programs is implemented in the PLC system, and is therefore implementation dependent. If a task with a priority higher than that of the task currently executing is activated, there are in principle two ways of resolving this conflict between tasks on the same CPU. It depends on the ability of the PLC system to interrupt a running task:
- 1. The task currently executing is interrupted immediately, to start execution of the task with higher priority. This is called pre-emptive scheduling.
- 2. The task currently executing is not interrupted, but continues normally until termination. Only then will the task with the highest priority of all waiting tasks be executed. This is called non-pre-emptive scheduling.
- Both methods give the task with the highest priority control of the requested resource. If a task with the same priority as the task currently executing is scheduled to execute, it has to wait. If tasks with the same priority are waiting to execute, the one which has been waiting longest will be executed first.

#### Example 6 3

##### Code

TASK T_Quick (INTERVAL := t#8ms, PRIORITY := 1);
PROGRAM Motion WITH T_Quick : ProgA ( RegPar := %MW3,
R_Val => ErrorCode);

TASK T_Interrupt (SINGLE := Trigger, PRIORITY := 1);
PROGRAM Lube WITH T_Interrupt : ProgC;

##### Caption

Example 6.3. Elements TASK and PROGRAM...WITH... from Example 6.6

#### Paragraphs After Example 6 3

- In Example 6.3, two tasks T_Quick (cyclic with short cycle time) and T_Interrupt (interrupt task with high priority) are defined.
- T_Quick is started every 8 milliseconds. If execution of the program Motion associated with it takes longer than this time (because of interruptions by tasks with higher priority, for example), the PLC system will report a run-time error.
- Program Lube has the same priority as Motion, so it has to wait if input Trigger changes to TRUE.
- Within the assignment of a program to a task, actual parameters can be specified, as shown here for RegPar of ProgA with a directly represented variable. At run time, these parameters are set on each invocation of the run-time program. In contrast to FBs, output parameters can be specified as well as input parameters, and these are also updated at the end of the program. In Example 6.3, this will be done for R_Val of ProgA. Assignments of output parameters to variables are specified with “=>” instead of “:=” to distinguish them from input parameters.
- If a PROGRAM is declared with no TASK association, this program will have lowest priority compared to all other programs and will be executed cyclically.

### Subsection 6 3 5

#### Title

6.3.5 ACCESS declarations

#### Paragraphs

- The VAR_ACCESS ... END_VAR language construct can be used to define access paths to serve as transparent communication links between configurations.
- Access paths are an extension of global variables, which are valid within one configuration only. For access paths, read and write attributes can be specified.
- Variables of one configuration are made known to other configurations under symbolic names.

#### Example 6 4

##### Code

VAR_ACCESS
CONV_EMPTY : CPU_Hammer.%IX1.0 : BOOL READ_ONLY;
...
END_VAR
Name of access path Variable to be accessed from outside Data type and read/write permission for access path

##### Caption

Example 6.4. Declaration of an access path

#### Paragraphs After Example 6 4

- Example 6.4 shows the structure of a declaration of an access path using variable CONV_EMPTY from Example 6.6.
- Access paths can be defined for the following types of variables:
- -Input and output variables of a PROGRAM -Global variables -Directly represented variables.
- Access paths publish these variables under a new name beyond the scope of a configuration, so that they can be accessed using communication blocks, for example.
- If a variable is a structure or an array, an access path can access only one single member or array element.
- By default, access paths allow only read access (READ_ONLY permission). By specifying READ_WRITE, write operations on this variable can be explicitly allowed.
- This permission must be specified immediately after the data type of the access variable. The data type of the access variable must be the same as that of the associated variable.

## Section 6 4

### Title

6.4 Configuration Example

### Paragraph 1

Example 6.5 shows an overview of a configuration. This example is declared textually in Examples 6.7 and 6.6. The configuration consists of a PLC system with two CPUs, which are assigned several programs and function blocks as run time programs. Parts of this example have already been discussed in previous sections of this chapter.

### Figure 6 5

#### Src

https://storage.googleapis.com/generativeai-downloads/images/244%206%20State-of-the-Art%20PLC%20Configuration.jpg

#### Alt

Example 6.5. Example of configuration elements with POUs (overview)

#### Title

Example 6.5. Example of configuration elements with POUs (overview)

### Paragraph After Figure 6 5

In Example 6.6, PLC_Cell1 physically consists of 2 CPUs. The first CPU can execute two tasks: one fast cyclic task with a short cycle time, and one slower cyclic task. The second CPU executes one task with interrupt property.

### Example 6 6

#### Code

CONFIGURATION PLC_Cell1
VAR_GLOBAL
ErrorCode : DUINT;
AT %MW3 : WORD;
Start : INT;
END_VAR
RESOURCE CPU_Conveyor ON CPU_001
TASK T_Quick (INTERVAL := t#8ms, PRIORITY := 1);
TASK T_Cyclic (INTERVAL := t#20ms, PRIORITY := 3);
PROGRAM Motion WITH T_Quick : ProgA (RegPar := %MW3);
PROGRAM Control WITH T_Cyclic : ProgB (InOut := Start,
R_Val => ErrorCode,
FB1 WITH T_Quick,
FB2 WITH T_Cyclic);
END_RESOURCE
RESOURCE CPU_Hammer ON CPU_002
VAR_GLOBAL
Trigger AT %IX2.5 : BOOL;
END_VAR
TASK T_Interrupt (SINGLE := Trigger, PRIORITY := 1);
PROGRAM Lube WITH T_Interrupt : ProgC;
END_RESOURCE
VAR_ACCESS
RegP : CPU_Conveyor.Motion.RegPar : WORD READ_WRITE;
CONV_EMPTY : CPU_Hammer.%IX1.0 : BOOL READ_ONLY;
END_VAR
VAR_CONFIG
CPU_Conveyor.Motion.RegPar.C2 AT QB17: BYTE;
END_VAR
END_CONFIGURATION

#### Caption

Example 6.6. Textual declaration of Example 6.5. Names of variables, programs and FBs are printed in bold type.

### Paragraph After Example 6 6

Variable C2, the storage location of which was not specified when declared in program ProgA, is assigned a concrete output byte with construct VAR_CONFIG .

### Example 6 7

#### Code

PROGRAM ProgA
VAR_INPUT
RegPar : WORD;
END_VAR
VAR
C2 AT %Q\*: BYTE;
END_VAR
...
END_PROGRAM

PROGRAM ProgB
VAR_IN_OUT
InOut : INT;
END_VAR
VAR_OUTPUT
R_Wert : DUINT;
END_VAR
...
CAL Inst_FB2
...
END_PROGRAM

PROGRAM ProgC
...
CAL Inst_FB3
...
END_PROGRAM

#### Caption

Example 6.7. Programs for Example 6.6; FB3 is not shown there, FB1 could implement error handling, for example.

### Paragraphs After Example 6 7

- In this example, run-time programs Motion, Control and Lube are created by associating programs ProgA, ProgB and ProgC respectively with a task definition.
- Program Motion and FB instance FB1 (independent of program Control) are executed on CPU_Conveyor as quick tasks (T_Quick). FB2 of program Control is executed on the same CPU (CPU_001) as a cyclic task (T_Cyclic). Program Control is used here to define the run-time properties of the FB tasks involved. Function block instances associated with tasks in this way are executed independently of the program.
- With every cyclic invocation of run-time program Control, the input parameter InOut is set to the value of variable Start. After termination of Control, the value of output parameter R_Val is assigned the global variable ErrorCode.
- On CPU_Hammer (the second CPU), program Lube is executed as an interrupt driven task (T_Interrupt). FB3, being part of ProgC, automatically inherits the same run-time behaviour.
- In this example, CPU_001 and CPU_002 are not variables, but manufacturer defined names for the CPUs of PLC_Cell1.

## Section 6 5

### Title

6.5 Communication between Configurations and POUs

### Paragraphs

- This section describes the means of exchanging data between different configurations and within one configuration, using shared data areas.
- Such (structured) data areas are used for communication between different program parts, for exchange of data, for synchronisation and to support diagnostics.
- It is the aim of IEC 61131-3 to provide a standardised communication model and thus enable the creation of well structured PLC programs, which facilitate commissioning and diagnostics and provide better documentation.
- Modularization of applications eases re-use, which helps to reduce the time taken to develop new applications.
- IEC 61131-3 defines several ways of exchanging data between different parts of a program:

### Communication Methods

- Directly represented variables,
- Input and output variables, and the return value, in POU calls,
- Global variables (VAR_GLOBAL, VAR_EXTERNAL),
- Access paths (VAR_ACCESS),
- Communication blocks (IEC 61131-5),
- Call parameters.

### Paragraphs After List

- The first three methods are for communication within one configuration, while access paths and communication blocks are intended for communication between different configurations, or with the outside world.
- Directly represented variables are not really intended to be used for communication between different parts of an application, but they are included in this list because their use is theoretically possible. Writing to PLC inputs (%I...) is not a suitable method. Outputs (%Q...) should be used to control the process, and not for temporary storage of internal information.
- As shown in Table 6.3, these methods can be used at several levels, and the different configuration elements and POUs have different rights of access.

### Table 6 3

| Communication Method          | CONF | RES | PROG | FB  | FUN |
| ----------------------------- | ---- | --- | ---- | --- | --- |
| Access path                   | x    | -   | x    | -   | -   |
| Directly represented variable | x    | x   | x    | -   | -   |
| Global variable               | x    | x   | x    | -   | -   |
| External variable             | -    | -   | x    | x   | -   |
| Communication block           | -    | -   | x    | x   | -   |
| Call parameter                | -    | x   | x    | x   | x   |

### Table 6 3 Key

Key: CON: CONFIGURATION
RES: RESOURCE
PROG: PROGRAM
FB: FUNCTION_BLOCK
FUN: FUNCTION

### Caption Table 6 3

Table 6.3. Communication methods available to configuration elements and POUs.

### Paragraphs After Table 6 3

- Access paths are used for exchanging data between configurations, i.e. across the boundaries of one PLC system, and can be used at configuration and program level.
- Directly represented variables of a PLC (i.e. %I, %Q and %M) allow limited communication between different parts of an application, as they can be accessed globally on one system. Flags (%M) can be used for synchronising events, for example.
- These variables may only be declared at program level or higher (i.e. globally), and function blocks may only access them with an external declaration. This is one important difference between IEC 61131-3 and previous PLC programming practice.
- Global variables can be declared for configurations, resources and programs, and can be used at these levels.
- Function blocks can access these variables (read and write) with an external declaration, but they cannot declare them themselves. Functions have no access to global or external variables.
- External variables can be imported by programs and function blocks if they have been declared globally elsewhere.
- Communication blocks are special function blocks used to transfer packets of data from the sender to the recipient. As these FBs are linked to one program, they are local to one configuration and not visible outside.
- The definition of such standard communication blocks is contained in Part 5 of IEC 61131 (Communication Services).
- Call parameters are used as input and output parameters when calling POUs. They can be used for transferring data into and out of a POU.
- As explained in Chapter 2, parameter assignment to input variables and the checking of output variables of a function block can take place independently of its invocation, thereby resulting in characteristics of a communication mechanism which was previously beyond the capabilities of PLC programming.
- Resources can pass values to programs when they are associated with tasks, as shown for Motion in Example 6.6. With every invocation, the values are passed as actual parameters or read as output parameters.
