# Chapter 5

## Title

5 Standardised PLC Functionality

## Introduction

- The IEC not only standardises the syntax of programming languages, but even goes a step further to unify the implementation of typical PLC functions, such as timers, counters or special arithmetic operations.
- The standard does this by defining typical PLC functions and function blocks and describing their behaviour exactly. These elements are known as standard functions and standard function blocks respectively. Their names are reserved keywords.
- If the functions and function blocks in the programming systems and block libraries of different manufacturers are given the names specified in the standard, they must comply with the rules set out in the standard. Manufacturers can also offer additional PLC functions which, for example, support particular hardware properties or other characteristics of a PLC system.
- The definition of an unambiguous standard for PLC functions is an essential requirement for uniform, manufacturer- and project-independent training, programming and documentation.
- This chapter gives an overview of the most important standard functions and function blocks as well as the concepts used within them:
- 1. Standard functions (std. FUN) -Calling interface -Extensibility -Overloading -Examples
- 2. Standard function blocks (std. FB) -Calling interface -Examples
- The standard functions correspond to the basic logical operators used in conventional PLC systems (addition, bit-shifting, comparison etc.), whereas the standard function blocks are responsible for PLC functions with status information, such as timers, counters, R/S flip-flops and edge detectors.

## Section 5 1

### Title

5.1 Standard Functions

### Introduction

- In the following sections, the calling interfaces (input and output variables and the function [return] value) for standard functions and function blocks are described in detail. Practical examples accompany the various descriptions.
- The graphical declarations of all standard functions and function blocks, together with a short functional description, are given in Appendices A and B.
- The general usage of functions and function blocks has already been discussed in Chapter 2 and the properties of their formal parameters in Chapter 3.
- IEC 61131-3 defines the following eight groups of standard functions:
- 1. Data type conversion functions, 2) Numerical functions, 3) Arithmetic functions, 4) Bit-string functions (bit-shift and bitwise Boolean functions), 5) Selection and comparison functions, 6) Character string functions, 7) Functions for time data types, 8) Functions for enumerated data types.
- Table 5.1 summarises all standard functions of the standard. The special functions for time data types (ADD, SUB, MUL, DIV, CONCAT) and enumerated data types (SEL, MUX, EQ, NE) are grouped together with the other functions in the categories Arithmetic, Comparison, Selection and Character string.
- The table gives the function name, the data type of the function values and a short description of the function. Together with Table 5.2, it also gives the names and data types of the input variables.
- With the exception of the generic data types, the abbreviations for the data types of the input variables and function values in Table 5.1 are listed in Table 5.2. These abbreviations correspond to the names of the input variables used by IEC 61131-3 for the respective standard functions. ENUM is an additional abbreviation used to make Table 5.1 clearer.

### Table 5 1

| Group            | Function (Input Types)            | Function Value Type | Short Description           | Overloaded | Extensible |
| ---------------- | --------------------------------- | ------------------- | --------------------------- | ---------- | ---------- |
| Type conversion  | \*_TO_\*\* (ANY)                  | ANY                 | Data type conversion        | yes        | no         |
| -                | TRUNC (ANY_REAL)                  | ANY_INT             | Rounding up/down            | yes        | no         |
| -                | BCD*TO*\*\* (ANY_BIT)             | ANY                 | Conversion from BCD         | yes        | no         |
| -                | \*\_TO_BCD (ANY_INT)              | ANY_BIT             | Conversion to BCD           | yes        | no         |
| -                | DATE_AND_TIME_TO_TIME_OF_DAY (DT) | TOD                 | Conversion to time-of-day   | no         | no         |
| -                | DATE_AND_TIME_TO_DATE (DT)        | DATE                | Conversion to date          | no         | no         |
| Numerical        | ABS (ANY_NUM)                     | ANY_NUM             | Absolute number             | yes        | no         |
| -                | SQRT (ANY_REAL)                   | ANY_REAL            | Square root (base 2)        | yes        | no         |
| -                | LN (ANY_REAL)                     | ANY_REAL            | Natural logarithm           | yes        | no         |
| -                | LOG (ANY_REAL)                    | ANY_REAL            | Logarithm to base 10        | yes        | no         |
| -                | EXP (ANY_REAL)                    | ANY_REAL            | Exponentiation              | yes        | no         |
| -                | SIN (ANY_REAL)                    | ANY_REAL            | Sine                        | yes        | no         |
| -                | COS (ANY_REAL)                    | ANY_REAL            | Cosine                      | yes        | no         |
| -                | TAN (ANY_REAL)                    | ANY_REAL            | Tangent                     | yes        | no         |
| -                | ASIN (ANY_REAL)                   | ANY_REAL            | Arc sine                    | yes        | no         |
| -                | ACOS (ANY_REAL)                   | ANY_REAL            | Arc cosine                  | yes        | no         |
| -                | ATAN (ANY_REAL)                   | ANY_REAL            | Arc tangent                 | yes        | no         |
| Arithmetic       | ADD {+} (ANY_NUM, ANY_NUM)        | ANY_NUM             | Addition                    | yes        | yes        |
| -                | ADD {+} a (TIME, TIME)            | TIME                | Time addition               | yes        | no         |
| -                | ADD {+} a (TOD, TIME)             | TOD                 | Time-of-day addition        | yes        | no         |
| -                | ADD {+} a (DT, TIME)              | DT                  | Date addition               | yes        | no         |
| -                | MUL {\*} (ANY_NUM, ANY_NUM)       | ANY_NUM             | Multiplication              | yes        | yes        |
| -                | MUL {\*} a (TIME, ANY_NUM)        | TIME                | Time multiplication         | yes        | no         |
| -                | SUB {-} (ANY_NUM, ANY_NUM)        | ANY_NUM             | Subtraction                 | yes        | no         |
| -                | SUB {-} a (TIME, TIME)            | TIME                | Time subtraction            | yes        | no         |
| -                | SUB {-} a (DATE, DATE)            | TIME                | Date subtraction            | yes        | no         |
| -                | SUB {-} a (TOD, TIME)             | TOD                 | Time-of-day subtraction     | yes        | no         |
| -                | SUB {-} a (TOD, TOD)              | TIME                | Time-of-day subtraction     | yes        | no         |
| -                | SUB {-} a (DT, TIME)              | DT                  | Date and time subtraction   | yes        | no         |
| -                | SUB {-} a (DT, DT)                | TIME                | Date and time subtraction   | yes        | no         |
| -                | DIV {/} (ANY_NUM, ANY_NUM)        | ANY_NUM             | Division                    | yes        | no         |
| -                | DIV {/} a (TIME, ANY_NUM)         | TIME                | Time division               | yes        | no         |
| -                | MOD (ANY_NUM, ANY_NUM)            | ANY_NUM             | Remainder (modulo)          | yes        | no         |
| -                | EXPT {\*\*} (ANY_NUM, ANY_NUM)    | ANY_NUM             | Exponent                    | yes        | no         |
| -                | MOVE {:=}(ANY_NUM, ANY_NUM)       | ANY_NUM             | Assignment                  | yes        | no         |
| Bit-shift        | SHL (ANY_BIT, ANY_INT)            | ANY_BIT             | Shift left                  | yes        | no         |
| -                | SHR (ANY_BIT, ANY_INT)            | ANY_BIT             | Shift right                 | yes        | no         |
| -                | ROR (ANY_BIT, ANY_INT)            | ANY_BIT             | Rotate right                | yes        | no         |
| -                | ROL (ANY_BIT, ANY_INT)            | ANY_BIT             | Rotate left                 | yes        | no         |
| Bitwise          | AND {&} (ANY_BIT, ANY_BIT)        | ANY_BIT             | Bitwise AND                 | yes        | yes        |
| -                | OR {>=1} (ANY_BIT, ANY_BIT)       | ANY_BIT             | Bitwise OR                  | yes        | yes        |
| -                | XOR {=2k+1} (ANY_BIT, ANY_BIT)    | ANY_BIT             | Bitwise EXOR                | yes        | yes        |
| -                | NOT (ANY_BIT, ANY_BIT)            | ANY_BIT             | Bitwise inverting           | yes        | no         |
| Selection        | SEL (G, ANY, ANY)                 | ANY                 | Binary selection (1 of 2)   | yes        | no         |
| -                | SEL b (G, ENUM, ENUM)             | ENUM                | Binary selection (1 of 2)   | no         | no         |
| -                | MAX c (ANY_E, ANY_E)              | ANY_E               | Maximum                     | yes        | yes        |
| -                | MIN c (ANY_E, ANY_E)              | ANY_E               | Minimum                     | yes        | yes        |
| -                | LIMITc (MN, ANY_E, MX)            | ANY_E               | Limitation                  | yes        | no         |
| -                | MUXc (K, ANY, ..., ANY)           | ANY                 | Multiplexer (select 1 of N) | yes        | yes        |
| -                | MUX b (K, ENUM, ..., ENUM)        | ENUM                | Multiplexer (select 1 of N) | no         | no         |
| Comparison       | GT {>} (ANY, ANY)                 | BOOL                | Greater than                | yes        | yes        |
| -                | GE {>=} (ANY, ANY)                | BOOL                | Greater than or equal to    | yes        | yes        |
| -                | EQ {=} (ANY, ANY)                 | BOOL                | Equal to                    | yes        | yes        |
| -                | EQ {=} b (ENUM, ENUM)             | BOOL                | Equal to                    | no         | no         |
| -                | LT {<} (ANY, ANY)                 | BOOL                | Less than                   | yes        | yes        |
| -                | LE {<=} (ANY, ANY)                | BOOL                | Less than or equal to       | yes        | yes        |
| -                | NE {<>} (ANY, ANY)                | BOOL                | Not equal to                | yes        | no         |
| -                | NE {<>} b (ENUM, ENUM)            | BOOL                | Not equal to                | no         | no         |
| Character string | LEN (STRING)                      | INT                 | Length of string            | no         | no         |
| -                | LEFT (STRING, L)                  | STRING              | string “left of”            | yes        | no         |
| -                | RIGHT (STRING, L)                 | STRING              | string “right of”           | yes        | no         |
| -                | MID (STRING, L, P)                | STRING              | string “from the middle”    | yes        | no         |
| -                | CONCAT (STRING, STRING)           | STRING              | Concatenation               | no         | yes        |
| -                | CONCAT a (DATE, TOD)              | DT                  | Time concatenation          | no         | no         |
| -                | INSERT (STRING, STRING, P)        | STRING              | Insertion (into)            | yes        | yes        |
| -                | DELETE (STRING, L, P)             | STRING              | Deletion (within)           | yes        | yes        |
| -                | REPLACE (STRING, STRING, L, P)    | STRING              | Replacement (within)        | yes        | yes        |
| -                | FIND (STRING, STRING)             | INT                 | Find position               | yes        | yes        |

### Table 5 1 Footnotes

- a Special function for time data type. The generic input and output data type for ADD and SUB is therefore ANY_MAGNITUDE, see also Section 3.4.3
- b Special function for enumeration data type
- c ANY_E is the abbreviation of ANY_ELEMENTARY

### Caption Table 5 1

Table 5.1. Overview of the standard functions (continued on next page)

### Table 5 2

| Input | Meaning                               | Data Type      |
| ----- | ------------------------------------- | -------------- |
| N     | Number of bits to be shifted          | ANY_INT        |
| L     | Left position within character string | ANY_INT        |
| P     | Position within character string      | ANY_INT        |
| G     | Selection out of 2 inputs (gate)      | BOOL           |
| K     | Selection out of n inputs             | ANY_INT        |
| MN    | Minimum value for limitation          | ANY_ELEMENTARY |
| MX    | Maximum value for limitation          | ANY_ELEMENTARY |
| ENUM  | Data type of enumeration              | -              |

### Caption Table 5 2

Table 5.2. Abbreviations and meanings of the input variables in Table 5.1

### Paragraphs After Table 5 2

- The function names are listed on the left-hand side of column 1 in Table 5.1. The meanings of the asterisks (\*) in the function names of the “Type conversion” group are as follows (see also Appendix A):
- - Data type of the input variable (right-hand side of column 1) \*\* Data type of the function value (column 2)
- The names of the input variables of a function, if any, are given in the italic heading of the group, if they apply to the group as a whole. For example, the input variables for arithmetic functions are named IN1, IN2 and, when extended, IN3, IN4, .... . If a function only has a single input variable, this does not have a name.
- If a function with several inputs has only one input of same data type (overloaded), its variable name is “IN” (without number). This applies to LIMIT, LEFT, RIGHT, MID and DELETE.
- Within IEC 61131-3, SEL is an exception to this uniformity. The inputs of this function are called G, IN0 and IN1 (instead of IN1, IN2).
- Some standard functions have an alternative function name consisting of symbols in their graphical representation, as shown in curved brackets directly after the function name in Table 5.1. For example, the addition function can be called as ADD (operator in IL) or as “+” (graphical symbol in LD/FBD or within ST expressions).

### Subsection 5 1 1

#### Title

5.1.1 Overloaded and extensible functions

#### Paragraphs

- The data types of the input variables are given in round brackets next to the function names in Table 5.1. Here generic data types, already introduced in Table 3.9, are also given for reasons of clarity. Each function whose input variable is described using a generic data type is called overloaded and has a “yes” in the corresponding column in Table 5.1. This simply means that the function is not restricted to a single data type for its input variables, but can be applied to different data types.
- The data type of the function value (2nd column) is normally the same as the data type of its inputs. Exceptions are functions such as LEN, which expects a character string as its input but returns INT as its function value.
- If a standard function can have a variable number of inputs (2, 3, 4,...), it is called extensible. Such functions have a “yes” in the corresponding column in Table 5.1.
- No formal parameters have to be entered when calling extensible functions. In textual languages they are called simply by using actual parameters separated by commas – in graphical representation the parameter names inside the boxes are omitted.
- In IEC 61131-3 these properties are not applied to user-defined functions, but can also be extended to these functions (and other POU types) as a supplement to the standard, depending on the programming system.
- Overloading and extensibility of standard functions are explained with the aid of examples in the next two sections.

#### Overloaded Functions

##### Title

Overloaded functions

##### Paragraphs

- Overloaded functions can be applied for processing several data types using only one function name.
- An overloaded function does not always support every data type of a generic data type, as explained in Chapter 3.
- For example, if a PLC programming system recognises the integer data types INT, DINT and SINT, only these three data types will be accepted for an overloaded function ADD which supports the generic data type ANY_INT.
- If a standard function is not overloaded, but restricted to a certain elementary data type, an underline character and the relevant data type must be added to its name: e.g. ADD_SINT is an addition function restricted to data type SINT. Such functions are called typed. Overloaded functions can also be referred to as type independent.
- This is illustrated in Example 5.1 using integer addition:

##### Example 5 1

###### Code

Graphical representation showing typed functions ADD_INT, ADD_DINT, ADD_SINT feeding into an overloaded ADD function.

###### Caption

Example 5.1. Typed standard functions ADD_INT, ADD_DINT and ADD_SINT for integer addition and the overloaded standard function ADD

##### Paragraphs After Example 5 1

- When overloaded functions are used, the programming system automatically chooses the appropriate typed function. For example, if the ADD function shown in Example 5.1 is called with actual parameters of data type DINT, the ADD_DINT function will automatically be selected and called (invisibly to the user).
- All derived data types made available by the PLC system are supported.
- When calling standard functions, each overloaded input and, in some cases, the function return value, must be of the same data type, i.e. it is not permissible to use variables of different types as actual parameters at the same time.
- If the inputs are of different data types, the PLC programmer must use explicit type conversion functions for the corresponding inputs and function return value respectively, as shown in Example 5.2 for ADD_DINT and ADD_INT. In such cases, instead of the overloaded function ADD its typed variant (e.g. ADD_DINT) should be used.

##### Example 5 2

###### Code

Graphical representation showing ADD calls with type conversions INT_TO_DINT, REAL_TO_DINT, DINT_TO_DWORD, SINT_TO_INT, INT_TO_SINT.

###### Caption

Example 5.2. Calls of the overloaded standard function ADD with type conversion functions to ensure correct input data types. In the top case the programming system replaces ADD with the typed standard function ADD_DINT. In the other two cases the function ADD_INT is used.

#### Extensible Functions

##### Title

Extensible functions

##### Paragraphs

- Extensible standard functions can have a variable number of inputs, between two and an upper limit imposed by the PLC system. In graphical representation, the height of their boxes depends on the number of inputs.
- Extending the number of inputs of a standard function serves the same purpose as using cascaded calls to the same function, in both the textual and the graphical programming languages of IEC 61131-3. Especially in the graphical languages LD and FBD, the amount of space required to write the function can be greatly reduced.

##### Example 5 3

###### Code

Graphical (Cascaded vs Extended), IL (Cascaded vs Extended), ST (Cascaded vs Extended) representations of adding Var1, Var2, Var3, Var4.

###### Caption

Example 5.3. Cascaded functions as an alternative representation for an extensible function showing addition in graphical and textual (IL and ST) representation

##### Paragraph After Example 5 3

In Example 5.3 the triple call of the standard function ADD is replaced by a single call with extended inputs. Simplifications also result for the textual versions in IL and ST.

### Subsection 5 1 2

#### Title

5.1.2 Examples

#### Paragraph 1

In this section the calling interfaces of the standard functions are shown in examples. The subject of calling functions has already been discussed in detail in Chapter 2.
At least one example has been selected from each function group in Table 5.1. The examples are given in the textual languages IL and ST and graphical representations LD and FBD. In IL and ST the names of the formal parameters are not specified explicitly in the function calls.
For these examples the PROGRAM ProgFrameFUN in Example 5.4 is used as the basis for the common declaration part for the required variables.

#### Example 5 4

##### Code

TYPE (_ enumeration type for colours _)
COLOURS : ( lRed, lYellow, lGreen, (_ light _)
Red, Yellow, Green, (_ normal _)
dRed, dYellow, dGreen); (_ dark _)
END_TYPE
PROGRAM ProgFrameFUN (_ common declaration part for std. FUNs _)
VAR (_ local data _)
RPM : REAL:= 10.5; (_ revs _)
RPM1 : REAL; (_ revs 1 _)
RPM2 : REAL := 46.8895504; (_ revs 2 _)
Level : UINT := 1; (_ revs level _)
Status : BYTE := 2#10101111; (_ status _)
Result : BYTE; (_ intermediate result _)
Mask : BYTE := 2#11110000; (_ bit mask _)
PLCstand : STRING [11]:= 'IEC 61131-5'; (_ character string _)
AT %IB2 : SINT; (_ for MUX selection _)
AT %QX3.0 : BOOL; (_ output bit _)
DateTime : DT := dt#1994-12-23-01:02:03; (_ date and time _)
VTime : TIME := t#04h57m57s; (_ time _)
TraffLight : COLOURS; (_ traffic light _)
ColScale1 : COLOURS:= lYellow; (_ scale of colours 1 _)
ColScale2 : COLOURS:= Yellow; (_ scale of colours 2 _)
ColScale3 : COLOURS:= dYellow; (_ scale of colours 3 _)
Scale : INT := 2; (_ selection scale of colours _)
END_VAR
... (_ program body with examples _)
END_PROGRAM

##### Caption

Example 5.4. Common declarations for the examples explaining the usage of the standard functions

#### Type Conversion Functions

##### Title

Type conversion functions

##### Example 5 5

###### Code

Graphical: RPM -->|REAL_TO_UINT|--> Level

Instruction List (IL):
LD RPM
REAL_TO_UINT
ST Level

Structured Text (ST):
Level := REAL_TO_UINT (RPM);

###### Caption

Example 5.5. Converting from REAL to UINT

##### Paragraph After Example 5 5

This example shows type conversion of the REAL value RPM (floating point) to the unsigned integer (UINT) value Level.
The variable Level has the value 10 after executing the function, as it is rounded down from 10.5.

#### Numerical Functions

##### Title

Numerical functions

##### Example 5 6

###### Code

Graphical: RPM -->|LN|--> RPM1

Instruction List (IL):
LD RPM
LN
ST RPM1

Structured Text (ST):
RPM1 := LN (RPM);

###### Caption

Example 5.6. Natural logarithm

##### Paragraph After Example 5 6

This example shows the calculation of a natural logarithm. Variable RPM1 has the value 2.3513 after execution.

#### Arithmetic Functions

##### Title

Arithmetic functions

##### Example 5 7

###### Code

Graphical: RPM -->|MUL|--> RPM
RPM1 -->| |
RPM2 -->| |

Instruction List (IL):
LD RPM
MUL RPM1
MUL RPM2
ST RPM

Structured Text (ST):
RPM := RPM _ RPM1 _ RPM2;

###### Caption

Example 5.7. Multiplication. Instead of using MUL twice in IL, the shortened form: MUL RPM1, RPM2 can also be used.

##### Paragraph After Example 5 7

This example uses the overloaded multiplication function. Because its inputs are of type REAL it is mapped to the typed function MUL_REAL. The variable RPM has the value 1157,625 after execution of the function.
In graphical representation, the multiplication sign “ \* ” may also be used instead of the keyword MUL. This is shown here only for ST.

#### Bit Shift Functions

##### Title

Bit-shift functions

##### Example 5 8

###### Code

Graphical: Status -->|SHL IN|--> Result
Level -->| N |

Instruction List (IL):
LD Status
SHL Level
ST Result

Structured Text (ST):
Result := SHL ( IN := Status, N := Level );

###### Caption

Example 5.8. Bit-shift left

##### Paragraph After Example 5 8

In Example 5.8 the shift function SHL is used to shift the value of the variable Status to the left by the number of bit positions specified by the value Level.
After executing the shifting function, Result has the value 2#01011110, i.e. when shifting left, a “0” is inserted from the right.

#### Bitwise Boolean Functions

##### Title

Bitwise Boolean functions

##### Example 5 9

###### Code

Graphical: Status -->|AND o|--> Result
Mask -->| |

Instruction List (IL):
LD Status
NOT
AND Mask
ST Result

Structured Text (ST):
Result := NOT Status & Mask;

###### Caption

Example 5.9. AND operation

##### Paragraph After Example 5 9

As the logical AND is an extensible function, the input parameter names need not be given (similar to MUL). AND is also an overloaded function, its inputs and function value here are of type BYTE. The programming system therefore automatically uses the typed function AND_BYTE.
Instead of the IL instructions LD and NOT in Example 5.9 the Boolean operator LDN (load negated) could be used. This inversion is graphically represented by a function input with a small circle.
In graphical representation, the normal AND symbol “&” may also be used instead of the keyword AND. This is shown here only for ST.
In Example 5.9 AND is used to extract certain bits from the value Status with the aid of a bit mask.
The output Result has the value 2#01010000 after executing the function, i.e. the lower four bits have been reset by the mask.

#### Selection Functions

##### Title

Selection functions

##### Example 5 10

###### Code

Graphical: %IB2 -->|MUX K|--> RPM
RPM1 -->| |
RPM2 -->| |

Instruction List (IL):
LD %IB2
MUX RPM1, RPM2
ST RPM

Structured Text (ST):
RPM := MUX ( K := %IB2, RPM1, RPM2 );

###### Caption

Example 5.10. Multiplexer

##### Paragraph After Example 5 10

The multiplexer MUX has an integer input K and overloaded inputs of the same data type as the function value. The input parameter names, with the exception of K, can therefore be left out. In Example 5.10 K is of data type SINT (integer Byte with sign).
If the input byte %IB2 has the value “1”, RPM is assigned the value RPM2 after execution, if it is “0”, it is assigned the value RPM1.
If the value of input K is less than 0 or greater than the number of the remaining inputs, the programming system or the run-time system will report an error (see also Appendix E).

#### Comparison Functions

##### Title

Comparison functions

##### Example 5 11

###### Code

Graphical (Extended): RPM -->|GE|--> %QX3.0
RPM1 -->| |
RPM2 -->| |

Graphical (Equivalent): RPM -->|>=|-->|&|--> %QX3.0
RPM1 -->| | | |
RPM1 -->|>=|-->| |
RPM2 -->| |

Instruction List (IL):
LD RPM
GE RPM1
AND( RPM1
GE RPM2
)
ST %QX3.0

Structured Text (ST):
%QX3.0 := GE ( RPM, RPM1, RPM2 );

###### Caption

Example 5.11. An extended comparison. An equivalent solution is shown in graphical representation on the right-hand side.

##### Paragraph After Example 5 11

Comparison functions use overloaded inputs, their output Q is Boolean. They represent a kind of “connecting link” between numerical/arithmetic calculations and logical/Boolean operations.
In the graphical representation of Example 5.11 the comparison function extended by one additional input is also shown as an equivalent call of three functions. Here the key words GE and AND are replaced by the symbols “>=” and “&”.

#### Character String Functions

##### Title

Character string functions

##### Example 5 12

###### Code

Graphical: PLCstand -->|REPLACE IN1|--> PLCstand
'-3' -->| IN2|
2 -->| L |
10 -->| P |

Instruction List (IL):
LD PLCstand
REPLACE '-3', 2, 10
ST PLCstand

Structured Text (ST):
PLCstand:= REPLACE ( IN2 := '-3', IN1 := PLCstand, P := 10, L := 2 );

###### Caption

Example 5.12. Example of “REPLACE” in IL and ST

##### Paragraph After Example 5 12

The function REPLACE has no overloaded inputs. When calling this function, both graphically and in ST, each input parameter must be entered with its name. Example 5.12 shows, that these inputs can then be entered in any order (see ST example). On the other hand, the order is fixed if there are no input parameter names (see IL example).
The character string PLCstand has the STRING value 'IEC 61131-3' after execution.

#### Functions for Time Data Types

##### Title

Functions for time data types.

##### Example 5 13

###### Code

Graphical: DateTime -->|ADD_TOD_TIME IN1|--> DateTime
Time -->| IN2|

Instruction List (IL):
LD DateTime
ADD_TOD_TIME Time
ST DateTime

Structured Text (ST):
DateTime := REAL_TO_UINT (DateTime, Time);

###### Caption

Example 5.13. An example of “ADD Time” in IL and ST. The standard now advises against using the “+“ sign for time operations.

##### Paragraph After Example 5 13

This time addition function (and also the corresponding subtraction) can be regarded as a continuation of overloaded addition — referring to mixed arguments: TIME, TIME_OF_DAY (TOD) and DATE_AND_TIME (DT).
The variable DateTime has the value DT#1994-12-23-06:00:00 after executing the function.
The addition and subtraction of time is not symmetrical. For subtraction, as opposed to addition, there are three additional operations for input data types DATE, TOD and DT. These operations are not available for addition, as it does not make much sense to add, for example, 10th October to 12th September.
In addition, it is not possible to add a TIME to a DATE, whereas this is possible for TIME, TOD and DT. In order to make this possible with DATE, the input must first be converted to DT and then added. Possible programming errors in time calculations can thus be avoided.

#### Functions for Enumerated Data Types

##### Title

Functions for enumerated data types

##### Example 5 14

###### Code

Graphical: Scale -->|MUX K|--> TraffLight
ColScale1 -->| |
ColScale2 -->| |
ColScale3 -->| |

Instruction List (IL):
LD Scale
MUX ColScale1, ColScale2, ColScale3
ST TraffLight

Structured Text (ST):
TraffLight := MUX ( K := Scale, ColScale1, ColScale2, ColScale3);

###### Caption

Example 5.14. An example of MUX with enumeration

##### Paragraph After Example 5 14

IEC 61131-3 defines functions for the data type enumeration, one of which, the selection function MUX, is shown in Example 5.14.
A variable of data type enumeration (type declaration COLOURS) is selected using the INT variable Scale.
After executing MUX the variable TraffLight will have the values “lYellow”, “Yellow” and “dYellow” from the colour scale (light, normal and dark) when the variable Scale has the values 0, 1 and 2 respectively.

## Section 5 2

### Title

5.2 Standard Function Blocks

### Introduction

- IEC 61131-3 defines several standard function blocks covering the most important PLC functions (with retentive behaviour).
- IEC 61131-3 defines the following five groups of standard FBs:
- 1. Bistable elements (= flip-flops) 2) Edge detection 3) Counters 4) Timers 5) Communication function blocks.
- Table 5.3 gives a concise list of all the standard FBs available in these groups. The table structure is very similar to the one for standard functions in Table 5.1. The communication FBs are defined in part 5 of IEC 61131 and not dealt with in this book.
- Instead of the data types of the input and output variables, their names are listed here. These names, together with their corresponding elementary data types, can be found in Table 5.4.

### Table 5 3

| Group             | Name (Input Params)      | Output Params | Short Description      |
| ----------------- | ------------------------ | ------------- | ---------------------- |
| Bistable elements | SR (S1, R)               | Q1)           | Set dominant           |
| -                 | RS (S, R1)               | Q1)           | Reset dominant         |
| Edge detection    | R_TRIG {->} (CLK)        | Q)            | Rising edge detection  |
| -                 | F_TRIG {-<} (CLK)        | Q)            | Falling edge detection |
| Counters          | CTU (CU, R, PV)          | Q, CV)        | Up counter             |
| -                 | CTD (CD, LD, PV)         | Q, CV)        | Down counter           |
| -                 | CTUD (CU, CD, R, LD, PV) | QU, QD, CV)   | Up/down counter        |
| Timers            | TP (IN, PT)              | Q, ET)        | Pulse                  |
| -                 | TON {T---0} (IN, PT)     | Q, ET)        | On-delay               |
| -                 | TOF {0---T} (IN, PT)     | Q, ET)        | Off-delay              |
| Communication     | -                        | -             | See IEC 61131-5        |

### Caption Table 5 3

Table 5.3. List of standard function blocks

### Table 5 4

| Inputs / Outputs | Meaning                     | Data Type |
| ---------------- | --------------------------- | --------- |
| R                | Reset input                 | BOOL      |
| S                | Set input                   | BOOL      |
| R1               | Reset dominant              | BOOL      |
| S1               | Set dominant                | BOOL      |
| Q                | Output (standard)           | BOOL      |
| Q1               | Output (flip-flops only)    | BOOL      |
| CLK              | Clock                       | BOOL      |
| CU               | Input for counting up       | R_EDGE    |
| CD               | Input for counting down     | R_EDGE    |
| LD               | Load (counter) value        | INT       |
| PV               | Pre-set (counter) value     | INT       |
| QD               | Output (down counter)       | BOOL      |
| QU               | Output (up counter)         | BOOL      |
| CV               | Current (counter) value     | INT       |
| IN               | Input (timer)               | BOOL      |
| PT               | Pre-set time value          | TIME      |
| ET               | End time output             | TIME      |
| PDT              | Pre-set date and time value | DT        |
| CDT              | Current date and time       | DT        |

### Caption Table 5 4

Table 5.4. Abbreviations and meanings of the input and output variables in Table 5.3

### Paragraphs After Table 5 4

- The counter inputs CU and CD are of data type BOOL and have an additional attribute R_EDGE, i.e. a rising edge has to be recognised in order to count up or down.
- The output values of each standard FB are zero when the FB is called for the first time.
- The input parameter names of the standard FBs are keywords. In IL they can be applied as operators to FB instances, as described in Section 4.1.4.
- The input parameters R and S have a second meaning in IL. There they are also the operators used to set and reset Boolean variables. This can cause difficulties that need to be solved when implementing programming systems.
- The concept of overloading inputs and outputs, as described in Section 5.1.1 for standard functions, applies also to standard function blocks.

### Subsection 5 2 1

#### Title

5.2.1 Examples

#### Paragraph 1

In this section, examples are given to illustrate the calling interfaces of standard function blocks in the same way as for the standard functions. The subject of FB calls has already been discussed in detail in Chapter 2.
At least one example is given for each function block group in Table 5.3. Both the textual languages IL and ST and the graphical representations LD and FBD are used.
In IL and ST the FB input parameter names are given explicitly in order to make the use of FB instances as clear as possible.
In the case of IL, the version of the function block call (see Section 4.1.4) that treats input parameters and return values as structure elements of the FB instance is used.
For the following examples, the PROGRAM ProgFrameFB in Example 5.15 is used as the basis for the common declaration part for the required variables and FB instances.

#### Example 5 15

##### Code

PROGRAM ProgFrameFB (_ common declaration part for std. FBs _)
VAR_GLOBAL RETAIN (_ global, battery-backed data _)
TimePeriod : TIME := t#63ms; (_ 63 milliseconds as initial value _)
END_VAR
VAR (_ local data _)
FlipFlop : RS; (_ flag _)
Button : R_TRIG; (_ edge detection button _)
Counter_UD : CTUD; (_ counter up/down _)
V_pulse : TP; (_ extended pulse _)
Pulse : BOOL; (_ pulse flag_)
EmOff : BOOL; (_ emergency off flag_)
AT %IX1.4 : BOOL; (_ emergency off _)
AT %IX2.0 : BOOL; (_ count up _)
AT %IX2.1 : BOOL; (_ load counter _)
AT %IX2.2 : BOOL; (_ start time _)
AT %IX3.0 : BOOL; (_ count down _)
AT %IW5 : INT; (_ count limit _)
AT %MX3.2 : BOOL; (_ flag _)
AT %QX3.2 : BOOL; (_ output _)
MaxReached : BOOL; (_ counter at max. limit _)
MinReached : BOOL; (_ counter at min. limit _)
CounterValue AT %MW2 : INT; (_ current counter value _)
TimerValue : TIME; (_ current timer value _)
DateAndTime : DT; (_ current date and time _)
END_VAR
... (_ program body for following examples _)
END_PROGRAM

##### Caption

Example 5.15. Common declarations for the examples on the usage of the standard function blocks

#### Bistable Element

##### Title

Bistable element (flip-flop)

##### Paragraph 1

These declarations contain:

- FB instances (from FlipFlop to V_pulse)
- Directly represented variables (from %IX1.4 to %QX3.2)
- Symbolic variable (CounterValue)
- General variables (others).
  The variables declared in the VAR section are declared as local variables and those declared in the VAR_GLOBAL RETAIN section are declared as battery backed global variables.

##### Example 5 16

###### Code

Graphical: %MX3.2 -->|RS S |--> %QX3.2
EmOff -->| R1 Q1|

Instruction List (IL):
LD %MX3.2
ST FlipFlop.S
LD EmOff
ST FlipFlop.R1
CAL FlipFlop
LD FlipFlop.Q1
ST %QX3.2

Structured Text (ST):
FlipFlop ( S := %MX3.2, R1 := EmOff);

###### Caption

Example 5.16. Bistable element (flip-flop)

##### Paragraph After Example 5 16

Example 5.16 shows how to use a flip-flop to store binary status information, in this case the value of flag %MX3.2.
The input R1 “dominantly” resets the output Q1, i.e. if both inputs are set to “1” the output remains “0”.

#### Edge Detection

##### Title

Edge detection

##### Example 5 17

###### Code

Graphical: %IX1.4 -->|R_TRIG CLK|--> EmOff
| Q |

Instruction List (IL):
LD %IX1.4
ST Button.CLK
CAL Button
LD Button.Q
ST EmOff

Structured Text (ST):
Button ( CLK := %IX1.4);
EmOff := Button.Q;

###### Caption

Example 5.17. Rising edge detection with R_TRIG

##### Paragraphs After Example 5 17

- FB instance Button of FB type R_TRIG in Example 5.17 evaluates the signal of an I/O bit and produces a “1” at Q when there is a rising edge (0→1 transition). To do this FB Button uses an internal edge detection flag that stores the “old” value of CLK in order to compare it with the current value.
- This information is stored for one program cycle (until the next call) and can be processed by other program parts even if %IX1.4 has already returned to “0” again. At the next call in the following cycle, the Button flag will again be reset.
- This means that for directly represented variables FB Button can only detect edges that occur at intervals of at least one program cycle.
- IEC 61131-3 provides FBs R_TRIG and F_TRIG not only for immediate usage as shown in Example 5.17. These FBs are also implicitly used for edge detection to implement the variable attributes R_EDGE and F_EDGE (see Chapter 3).
- Example 5.18 shows variable declaration using an edge-triggered input (bold text) within the declaration part of FB ExEdge.

##### Example 5 18

###### Code

FUNCTION_BLOCK ExEdge
VAR_INPUT
Edge : BOOL R_EDGE; (_ edge-triggered _)
END_VAR
VAR_OUTPUT
Flag : BOOL;
END_VAR
...
LD Edge; (_ access to edge flag _)
ST Flag;
...
END_FUNCTION_BLOCK

###### Caption

Example 5.18. A declaration with R_EDGE for edge detection and usage in IL

##### Paragraph After Example 5 18

To make the use of edge-triggered variables clearer, Example 5.19 shows how additional instructions which implement edge detection are added to Example 5.18. This is done — invisibly to the user — by the programming system.

##### Example 5 19

###### Code

FUNCTION_BLOCK ExEdge
VAR_INPUT
Edge : BOOL; (_ edge-triggered _)
END_VAR
VAR_OUTPUT
Flag : BOOL;
END_VAR
VAR
EdgeDetect: R_TRIG; (_ FB instance "rising edge" _)
END_VAR
...
CAL EdgeDetect (CLK := Edge); (_ FB call for edge detection _)
LD EdgeDetect.Q; (_ load detection result from FB instance _)
ST Flag;
...
END_FUNCTION_BLOCK

###### Caption

Example 5.19. Automatic extension of Example 5.18 using R_TRIG

##### Paragraph After Example 5 19

The declaration of FB EdgeDetect in Example 5.19 is inserted implicitly and invisibly by the programming system. This FB is called with input variable Edge. Its output value EdgeDetect.Q is then used wherever the value Edge is originally accessed.
This example shows why IEC 61131-3 does not allow this kind of edge detection for output variables: these variables could be overwritten at any point within the POU. This would, however, violate the rule that FBs are not allowed to change the outputs of other called FBs! See also Section 2.3.2.

#### Counter

##### Title

Counter

##### Example 5 20

###### Code

Graphical: %IX2.0 -->|CTUD CU QU|--> MaxReached
%IX3.0 -->|NOT CD QD|--> MinReached
%IX1.4 -->| R |
%IX2.1 -->| LD |
%IW5 -->| PV CV|--> CounterValue

Instruction List (IL):
LD %IX2.0
ST Counter_UD.CU
LDN %IX3.0
ST Counter_UD.CD
LD %IX1.4
ST Counter_UD.R
LD %IX2.1
ST Counter_UD.LD
LD %IW5
ST Counter_UD.PV
CAL Counter_UD
LD Counter_UD.QU
ST MaxReached
LD Counter_UD.QD
ST MinReached
LD Counter_UD.CV
ST CounterValue

Structured Text (ST):
Counter_UD ( CU := %IX2.0
CD := NOT(%IX3.0),
R := %IX1.4,
LD := %IX2.1,
PV := %IW5);
MaxReached := Counter_UD.QU;
MinReached := Counter_UD.QD;
CounterValue := Counter_UD.CV;

###### Caption

Example. 5.20. The up/down counter CTUD

##### Paragraph After Example 5 20

In this example, each input of the up/down counter Counter_UD is used. This is, however, not always necessary.
The inputs CU and CD can be activated simultaneously by a rising edge. In this case the current counter value would not change if the minimum or maximum had not already been reached.
Counter_UD in Example 5.20 counts up with each rising edge at %IX2.0 and counts down with each falling edge at %IX3.0. If CU and CD were assigned the same variable or constant, the counter would count up by one increment and immediately afterwards down again by one increment, in response to the signal.
The pre-set counter value at PV is loaded from %IW5 if the load input LD is active when the FB is called. No rising edge is needed in this case.

#### Timer

##### Title

Timer

##### Paragraph 1

Example 5.21 is an example of the usage of timer FBs. It demonstrates clearly how instances of timers maintain their values, especially those of the input parameters, between calls.
In principle, each input variable of a timer (or any FB) can be set immediately before calling. Such run-time parameter changes could be used to allow the same timer to be used to control several process times simultaneously. Such programming is, however, seldom used in practice as it makes the program difficult to read and can easily lead to errors.
It is sufficient to set the pre-set timer value PT for each instance only once, with the first call, and then to re-use it for later invocations. This means that calling the timer primarily serves to start the timer with input IN.
The output variables of a timer can be checked at any point in the program, i.e. they need not be evaluated immediately after calling the timer.
The output parameters are set at each call of the timer FB, i.e. they are updated with the current values of the physical timer running in the background. The timer value may therefore become obsolete between two timer calls. Therefore, in order to avoid distorting the desired time control, it must be ensured that the timer FB is called sufficiently frequently in a periodic task, not too long before Q or ET are evaluated.
Output Q shows whether the time has elapsed or not, and output ET shows the time still remaining.
Timers are thus usually called in the following steps:

##### Timer Steps

- 1. Setting of the timer value
- 2. Periodic calling with updating
- 3. Checking of the timer values.

##### Paragraph After List

In a PLC program executing periodically, these three steps are often combined in a single call. This simplifies the program and makes the graphical representation easier.
The behaviour of the different timers is shown in more detail in Appendix B.

##### Example 5 21

###### Code

Graphical: %IX2.2 -->|TP IN Q|--> Pulse
TimePeriod -->| PT ET|--> TimerValue

Instruction List (IL):
(_ 1. set pulse length _)
LD TimePeriod
ST V_pulse.PT
...
(_ 2. start timer _)
LD %IX2.2
ST V_pulse.IN
CAL V_pulse
...
(_ 3. get current timer value _)
LD V_pulse.Q
ST Pulse
LD V_pulse.ET
ST TimerValue

Structured Text (ST):
(_ 1. set pulse length _)
V_pulse.PT := TimePeriod;
...
(_ 2. start timer _)
V_pulse ( IN := %IX2.2);
...
(_ 3. get current timer value _)
Pulse := V_pulse.Q;
TimerValue := V_pulse.ET;

###### Caption

Example 5.21. Creating pulses using the timer TP

##### Paragraph After Example 5 21

Example 5.21 shows the three steps required when using the instance V_pulse:

1. The timer value for V_pulse is pre-set to 63 milliseconds.
2. V_pulse is started by input bit 2.2.
3. V_pulse is evaluated by checking Q and ET.
   Note:
   The timer FB RTC (real-time clock) is no longer included in IEC 61131-3.
