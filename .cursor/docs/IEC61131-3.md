# Chapter 3

## Title

3 Variables, Data Types and Common Elements

## Introduction

- This chapter presents the syntax and semantics of the basic, common language elements of all programming languages of IEC 61131-3.
- The syntax describes the language elements IEC 61131-3 makes available for its programming languages and how they may be used and combined with each other; their meaning is governed by the semantics.
- The first section deals with the “simple language elements” which represent the basic elements of the languages.
- “Data type definition” and “variable declaration” are then explained at length.

## Section 3 1

### Title

3.1 Simple Language Elements

### Paragraph 1

Every PLC program consists of a number of basic language elements or “smallest units” put together to form declarations and/or statements and finally whole programs. These simple language elements can be divided into:

### Elements List

- Delimiters,
- Keywords,
- Literals,
- Identifiers.

### Example 3 1

#### Code

FUNCTION RealAdd: REAL (_ function heading _)
VAR_INPUT (_ variable type "input" _)
Inp1, Inp2: REAL; (_ variable declaration _)
END_VAR (_ end of variable type _)
RealAdd := Inp1 + Inp2 + 7.456E-3; (_ ST statement _)
END_FUNCTION (_ end of the function _)

#### Caption

Example 3.1. Function declaration with “simple language elements” in ST. Keywords are shown in bold type, identifiers in normal type and the literal in italics. Delimiters are colon, comma, parentheses, asterisk, equal, plus, minus and semicolon.

### Paragraphs After Example 3 1

- The function RealAdd describes a function for floating-point (REAL) addition of two input values Inp1, Inp2 and the constant 7.456 \*10-3. It consists of a declaration part (VAR_INPUT), in which the names and types of the two input parameters are declared, as well as a single statement line in the language Structured Text (ST).
- In Example 3.1 the keywords are shown in bold type. This is the fixed notation specified by IEC 61131-3 for structuring declarations and statements. These keywords are the elementary “words” of the programming languages of IEC 61131-3.
- The user-specific identifiers are shown in normal type. They are used by the PLC programmer for naming variables, functions etc.
- The only literal employed here (in this case a “numeric literal”) is printed in italics and designates a constant in floating-point representation with exponent information. The values of the data types are represented by literals, for example, numbers or character strings.
- The delimiters in Example 3.1 are the remaining symbols and blank spaces between the other elements. These are listed in Appendix H.2 and will not be discussed here.
- Table 3.1 shows further examples:

### Table 3 1

| Language Element | Meaning                                                                              | Examples                                 |
| ---------------- | ------------------------------------------------------------------------------------ | ---------------------------------------- |
| Delimiters       | Special characters with different meanings                                           | (,),+,-,\*,$,;,:=,#, space               |
| Keywords         | Standard identifiers as “words” of the programming languages                         | RETAIN, VAR_INPUT, END_VAR, FUNCTION     |
| Literals         | Value representations for different data types                                       | 62, 3.4509E-12, 16#a5                    |
| Identifiers      | Alphanumeric character strings for user-specific variable names, labels or POUs etc. | Var_1, Inp1, EmergOff, REAL_OUT, RealAdd |

### Caption Table 3 1

Table 3.1. Examples of simple language elements

### Subsection 3 1 1

#### Title

3.1.1 Reserved keywords

#### Paragraphs

- Keywords are standard identifiers whose spelling and intended purpose are clearly defined by IEC 61131-3.
- They cannot therefore be employed for user-defined variables or other names.
- The use of upper or lower case letters is not significant for keywords i.e. they can be represented as desired, upper case, lower case or a mixture of the two. For better distinction, the keywords in this book are generally printed in upper case.
- The reserved keywords also include:

#### Reserved Keywords List

- Names of elementary data types
- Names of standard functions (std. FUN)
- Names of standard function blocks (std. FB)
- Names of input parameters of standard functions
- Names of input and output parameters of standard FBs
- Variables EN and ENO in graphical programming languages
- Operators in the language Instruction List
- Elements of the language Structured Text
- Language elements of the language Sequential Function Chart.

#### Paragraph After List

The reserved keywords defined in IEC 61131-3 are listed in Appendix H.1 and are not discussed here.

## Section 3 2

### Title

3.2 Literals and Identifiers

### Subsection 3 2 1

#### Title

3.2.1 Literals

#### Paragraphs

- Literals represent the values of variables (constant factors). The format depends on the data types of the variables, which in turn determine the possible value ranges.
- Table 3.2 gives some typical examples of literals for number representation. There are three basic types of literals:

#### Literal Types List

- Numeric literals (numeric values for bit string numbers as well as integers and floating-point numbers)
- Character string literals (values of character strings – in single-byte or double byte representation)
- Time literals (values for time, duration and date).

#### Table 3 2

| Data Type                                       | Number Representation                                        | Remarks                                                                                                                                     |
| ----------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------- |
| Boolean                                         | FALSE, TRUE                                                  | Bit string numbers<br>Boolean representation                                                                                                |
| Byte                                            | 11, 16#0B, 2#0000_1011                                       | Number 11 in decimal, hexadecimal and binary notation                                                                                       |
| Double word                                     | 16#ABCDEF, 16#ab_cdef                                        | Number 11.259.375 hexadecimal                                                                                                               |
| Integer with type notation                      | +3829, -45<br>DINT#5, UINT#16#9AF,<br>BOOL#0, BOOL#TRUE      | Integers and floating-point numbers<br>Integer, with and without sign,<br>with and without sign,<br>also Boolean                            |
| Floating point                                  | 567.82, -0.03                                                | Real                                                                                                                                        |
| Floating point                                  | 667E+4, -29E-16, 3e6                                         | Real with exponent                                                                                                                          |
| Character string                                | ''                                                           | Character strings<br>Empty character string                                                                                                 |
| Character string                                | 'this is a text'                                             | Non-empty character string: "this is a text"                                                                                                |
| Character string                                | 'ÄË', '$C4$CB'                                               | Two identical character strings in hexadecimal notation of the values of the ISO/IEC 10646-1 character set, but with double quotation marks |
| Double-byte character string with type notation | ''ÄË'', ''$00C4$00CB''<br>STRING# 'YES',<br>WSTRING# ''YES'' | Three single-byte characters<br>Three double-byte characters                                                                                |
| Duration                                        | t#1d2h7m19s45.7ms<br>time#2h_7m_19s<br>TIME#-22s150ms        | Time, Duration and Date<br>Specification of days (d), hours (h), minutes (m), seconds (s) and milliseconds (ms), also negative values       |
| Date                                            | d#1994-09-23                                                 | Specification of year-month-day                                                                                                             |
| Time of day                                     | tod#12:16:28.44                                              | Specification of hours:minutes:seconds.hundredths                                                                                           |
| Date and time                                   | dt#1994-09-23-12:16:28.44                                    | Date and time of day combined with “-”                                                                                                      |

#### Caption Table 3 2

Table 3.2. Examples of literals of different data types. As for keywords, upper case/lower case is not significant. (Continued on next page)

#### Paragraphs After Table 3 2

- Numeric and time literals may contain additional underline characters in order to give a better optical representation. Upper case/lower case is unimportant.
- The most significant unit in a duration literal may “overflow”, e.g. the duration value t#127m_19s is valid and the programming system makes the conversion into the “correct” representation t#2h_7m_19s.
- While a duration serves for the measurement and processing of a relatively elapsed time, the remaining time literals represent absolute times of day and dates.
- Literals for times and date can be represented in short form or written out in full for ease of reading. Table 3.3 shows columns of equivalents.

#### Table 3 3

| Duration | Date  | Time of Day  | Date and Time  |
| -------- | ----- | ------------ | -------------- |
| TIME#    | DATE# | TIME_OF_DAY# | DATE_AND_TIME# |
| T#       | D#    | TOD#         | DT#            |
| time#    | date# | time_of_day# | date_and_time# |
| t#       | d#    | tod#         | dt#            |
| Time#    | dATE# | Time_of_Day# | dAtE_aNd_TiMe# |

#### Caption Table 3 3

Table 3.3. Long and short form of the prefix for time and date literals.

#### Paragraphs After Table 3 3

- Character string literals are represented between single quotation marks. The dollar sign (“$”) is used as a prefix to enable special characters to be included in a character string. Non-printable special characters are used for formatting text for display or printout.
- Dollar signs and quotation marks themselves must therefore be identified by an additional preceeding “$”.
- Table 3.4 gives a guide to the rules for special characters.

#### Table 3 4

| $ Combination               | On Screen or Printer                         |
| --------------------------- | -------------------------------------------- |
| $nn                         | Character “nn” in hexadecimal representation |
| $$                          | Dollar sign                                  |
| $', $“                      | Single or double quotation mark              |
| $L, $l                      | Line feed (= $0A)                            |
| $N, $n                      | New line                                     |
| $P, $p                      | New page                                     |
| $R, $r                      | Carriage return (= $0D)                      |
| $T, $t                      | Tab                                          |
| 'one $'piece$' costs $$ 45' | Character string: “one 'piece' costs $ 45”   |

#### Caption Table 3 4

Table 3.4. Use of the $ sign in character strings (STRING, WSTRING)

#### Paragraph After Table 3 4

The characters immediately following a dollar sign can be written in upper or lower case.

### Subsection 3 2 2

#### Title

3.2.2 Identifiers

#### Paragraphs

- Identifiers are alphanumeric character strings which the PLC programmer can use to assign individual names for variables, programs etc. Table 3.5 lists the language elements of IEC 61131-3 for which names can be assigned.

#### Table 3 5

- Jump and network labels
- Enumeration constants
- Configurations, Resources, Tasks/Run-time programs
- Programs, Functions, Function blocks
- Access paths
- Variables (general, symbolic and directly represented variables)
- Derived data types, Components of a structure
- Transitions, Steps, Action blocks

#### Caption Table 3 5

Table 3.5. Language elements of IEC 61131-3 for which identifiers (names) can be assigned

#### Paragraphs After Table 3 5

- Identifiers begin with a letter or a (single) underline character, followed by as many letters, digits and underline characters as desired.
- No distinction is made between upper and lower case letters, i.e. the variable “EMERG_OFF” is identical to “Emerg_Off” or “emerg_off”. The programming system assigns the same storage space to these three identifiers.
- The length of identifiers is limited only by the ability of the programming system. IEC 61131-3 requires (at least) the first six characters of an identifier to be unambiguous i.e. these are significant.
- If, for example, a programming system allows 16 characters per identifier name, the programmer must ensure that the first six characters of a name are unique to this identifier: The variable names \_DRILLTOOL_8 and \_DRILL are considered to be identical in a system with only six significant places. 32 or more significant places are quite usual in a modern system.
- Table 3.6 gives some examples of valid and invalid identifiers.

#### Table 3 6

| Valid Identifiers            | Invalid Identifiers |
| ---------------------------- | ------------------- |
| MW2                          | 2MW                 |
| VALVE3X7, Valve3x7           | 3X7                 |
| EMERG_OFF, Emerg_Off         | Emerg Off           |
| EMERGOFF, EmergOff           | -                   |
| \_DRILLTOOL_8, \_drilltool_8 | \_\_DRILL           |
| \_DRILLTOOL, \_DRILL         | -                   |
| \_3ST91                      | \_3ST9$1, \_3ST9.1  |

#### Caption Table 3 6

Table 3.6. Examples of valid and invalid (crossed out) identifiers

### Subsection 3 2 3

#### Title

3.2.3 Comments

#### Paragraphs

- Comments may be used wherever empty spaces are allowed, except in string character literals. They are introduced by the two characters “left parenthesis” and asterisk “(_“ and concluded symmetrically with ”_)”.
- Comments must not be nested and have no syntactic or semantic significance to declarations or one of the languages defined by IEC 61131-3.

### Subsection 3 2 4

#### Title

3.2.4 Pragmas

#### Paragraphs

- The standard explicitly allows so-called pragmas, which are typically used for automatic pre-processing and post-processing of programs. These elements are identified by braces. Their syntax and semantics depend on the implementation by the programming system. They are therefore not defined by the standard itself.
- Pragmas may be used wherever comments are allowed.
- {Author MT, Version D4.1} {n := 4}

#### Example 3 2

##### Caption

Example 3.2. Example of pragmas that are not defined by the standard itself.

## Section 3 3

### Title

3.3 Meanings of Data Types and Variables

### Paragraph 1

Variables are declared in the declaration part of a POU, i.e. they are “introduced” together with their properties (see also Sections 2.3.2 and Example 2.10). Variable declarations are independent of the chosen programming language and therefore uniform for the entire PLC project. Declarations essentially consist of an identifier (variable name) as well as information about the data type used. Type definitions contain the application-specific (derived) data types and are valid project-wide.

### Paragraph 2

Before the practical use of data types and variables can be explained in depth (in Sections 3.4 and 3.5), the meaning of these PLC programming terms, which are new for the classical PLC world, will be explained.

### Subsection 3 3 1

#### Title

3.3.1 From direct PLC addresses via symbols to variables

#### Paragraphs

- In conventional PLC programming (see DIN 19239) it is normal to access addresses in PLC memory directly using “operands”, such as “M 3.1” (flag, or memory bit 3.1) or “IW 4” (input word 4). These addresses can either be in the main memory of the PLC central processing unit (CPU) or, for example, in the I/O modules (inputs and outputs ). Addresses are typically accessed as bit, byte, word or double word.
- The memory areas addressed by physical addresses can be used for different purposes in the PLC program: as integer or BCD value (e.g. BYTE or WORD), as a floating-point number (e.g. REAL, LREAL) or as a timer or counter value (e.g. INT), etc. This means that the memory cell has a specific data format in each case (8, 16, 32 bits). These data formats are in general incompatible with each another and programmers have to remember in which format the PLC addresses in a program may be used.
- Erroneous programs may result when an incorrect memory address is specified (address areas of 16KB and more are often available) or an address is used in the wrong data format.
- For many PLC systems “symbols”, which can be used equivalently in place of the absolute PLC addresses, were therefore introduced to ensure a more readable PLC program. Every address is assigned a unique symbolic name by means of an assignment list or symbol table. This use of symbolic representation as a “variable substitute” is shown on the left-hand side of Example 3.3.
- IEC 61131-3 goes one step further: in place of the hardware addresses or symbols, the use of variables is defined, as is normal in high-level programming languages. Variables are identifiers (names) assigned by the programmer, which act as “placeholders” and contain the data values of the program.
- Example 3.3 shows the PLC addresses and symbols on the left-hand side compared with the corresponding IEC 61131-3 declarations on the right-hand side.

#### Example 3 3

##### Code

PB 123:
Assignment list (symbol table):
I3.4 = InpVar
M70.7 = FlagVar
Q1.0 = OutVar

A InpVar
A FlagVar
ON M70.6
= OutVar
...

PROGRAM ProgIEC
VAR
InpVar AT %IX3.4 : BOOL;
FlagVar : BOOL;
OutVar AT %QX1.0 : BOOL;
AT %MX70.6 : BOOL;
END_VAR

LD InpVar
AND FlagVar
ORN %MX70.6
ST OutVar
...

##### Caption

Example 3.3. Introduction of the terms “variable” and “data type” by IEC 61131-3. On the left-hand side of the bottom box is a simple IL (=STL) program section according to DIN 19239, on the right-hand side is the corresponding code using IEC 61131-3.

#### Paragraphs After Example 3 3

- As already described in Chapter 2, every variable of a POU is declared in a declaration block, i.e. it is defined with all its properties. In Example 3.3 (on the right-hand side) the variable type VAR is used for declaration of local variables. The use of the keyword AT shown here, as well as addresses beginning with “%” are explained in Section 3.5.1.
- The symbols or variables InpVar and OutVar in Example 3.3 are addressed directly as hardware addresses “I 3.4” and “Q 1.0” of the PLC. The PLC address “M 70.6” is used directly without a symbol or variable name. All the addresses and variables in this example are “Boolean” (with binary values 0 and 1). Therefore the data type “BOOL” (abbreviation for Boolean) is specified on the right in each case.
- The variable FlagVar is declared on the right without direct assignment to a PLC address. The programming system does this automatically when compiling the program, by finding and assigning a free memory address (such as M 70.7).

### Subsection 3 3 2

#### Title

3.3.2 The data type determines the properties of variables

#### Paragraphs

- IEC 61131-3 uses variables not only for PLC addresses but uniformly for all user data of the PLC program, particularly for data that need not be at a specific memory location or PLC address (“general” variables).
- Variables have properties which are determined by the so-called data type assigned to them. While the variable name corresponds to the storage space of a variable, the data type indicates which values the variable can have.
- Data types determine variable properties such as initial value, range of values or number of bits (data width). A variable is declared by assignment of a data type to an identifier (variable name) and is thereby made known to the POU and to other POUs.
- In Example 3.4 the variable Start is declared as a local variable with the properties of the data type BYTE. BYTE is a standard data type of IEC 61131-3 (“elementary data type”), see also Appendix D. Avariable like Start declared with BYTE has the initial value 0, a value range of 0 to 255 and occupies 8 bits.

#### Example 3 4

##### Code

VAR
Start : BYTE; (_declaration of variable "Start" with data type BYTE _)
END_VAR

##### Caption

Example 3.4. A simple variable declaration, consisting of the identifier Start (variable name) and the colon, followed by the elementary data type BYTE. It is concluded with a semicolon.

#### Paragraph After Example 3 4

The properties of variables also depend on additional information in their declaration and on properties of the variable type in whose block they are declared.

### Subsection 3 3 3

#### Title

3.3.3 Type-specific use of variables

#### Paragraphs

- When a variable is accessed, the programming system can check the type-specific use of the variable i.e. whether the variable is processed in accordance with its data type. This is a significant advantage compared to previous PLC programming where such checks were system-specific and could only be partially carried out, if at all.
- This type checking is carried out automatically by the programming system while compiling the PLC program. The programmer can be warned, for example, if a variable of type BYTE (such as Start in Example 3.4) is assigned a value of the type REAL (floating-point number).
- Because the properties of a variable are determined by its data type, errors caused by incorrect use of the data format can be avoided to a large extent (see also Section 3.3.1).
- A further example can be seen in Example 3.5 where counter values are declared as typical variables of type integer with or without signs.

#### Example 3 5

##### Code

CounterBackward : INT; (_ signed integer _)
CounterForward : UINT; (_ unsigned integer _)

##### Caption

Example 3.5. Use of the predefined data types “(un)signed integer” for the declaration of counter variables

#### Paragraph After Example 3 5

In Example 3.5 the two variables CounterBackward and CounterForward are assigned the data types INT and UINT. This establishes that CounterBackward can have values from -32768 to 32767 and CounterForward has the range of values between 0 and 65535.
A programming system at least issues a warning if, for example, these two variables are used together in a logic operation, e.g. comparison or addition.

### Subsection 3 3 4

#### Title

3.3.4 Automatic mapping of variables onto the PLC

#### Paragraphs

- For many variables of a POU (temporary data etc.) it is unimportant in which PLC memory area they are kept, as long as enough storage space is available. As already described in Section 3.3.1, an explicit “manual” memory division is necessary in the case of many previous programming systems. This can lead to errors, especially with complex computations and/or large memory areas.
- Using the variable concept of IEC 61131-3, such “general” variables, which were previously managed manually in the global (non-local) “flag area” of the PLC, are automatically mapped onto a corresponding storage space in the PLC during compilation of the program. The programmer does not have to take care of assigning the variables to physical addresses. This corresponds to the procedure used by compilers for normal high-level programming languages.
- The use of general variables such as FlagVar in Example 3.3 or the variables in Examples 3.4 and 3.5 is simpler and more reliable than the direct use of memory addresses in the PLC. An inadvertent double or incorrect assignment of memory areas by the programmer is automatically excluded.

## Section 3 4

### Title

3.4 Data Types

### Paragraphs

- Traditional PLC programming languages contain data types such as floating-point representation, BCD code or timer and counter values, which often have completely incompatible formats and coding.
- For example, floating-point representation, for which the keywords REAL, FLOAT etc. are used, is typically implemented by 32-bit data words, and different value ranges are additionally employed for fraction and exponent.
- Most traditional programming systems have a uniform use of BIT, BYTE, WORD and DWORD. However, even for simple integer values, there are fine but distinctive differences (with/without sign, number of bits) between the PLC systems of different manufacturers.
- Therefore, in most cases program porting with incompatible data types requires large programming modifications, which are highly error-prone.
- As a result of IEC 61131-3, the most common data types used in PLC programming are defined so that their meaning and use within the PLC world are uniform. This is of particular interest to machine and plant builders and engineering offices who work with several PLC and programming systems from different manufacturers. Uniform data types are the first step towards portable PLC programs.

### Subsection 3 4 1

#### Title

3.4.1 Elementary data types

#### Paragraph 1

In IEC 61131-3 there is a set of predefined, standardised data types called Elementary data types, which are summarised in Table 3.7, see also Appendix D.

#### Table 3 7

| Boolean/stringbit | Signed Integer | Unsigned Integer | Floating Point (Real) | Time, Duration, Date and Character String |
| ----------------- | -------------- | ---------------- | --------------------- | ----------------------------------------- |
| BOOL              | INT            | UINT             | REAL                  | TIME                                      |
| BYTE              | SINT           | USINT            | LREAL                 | DATE                                      |
| WORD              | DINT           | UDINT            | -                     | TIME_OF_DAY                               |
| DWORD             | LINT           | ULINT            | -                     | DATE_AND_TIME                             |
| LWORD             | -              | -                | -                     | STRING                                    |

#### Table 3 7 Footnote

Meaning of the first letters: D = double, L = long, S = short, U = unsigned

#### Caption Table 3 7

Table 3.7. The elementary data types of IEC 61131-3. Their names are reserved keywords.

#### Paragraph After Table 3 7

The elementary data types are characterised by their data width (number of bits) as well as their possible value range. Both values are defined by the IEC.
Exceptions to this rule are the data width and range of date, time and string data types which are implementation-dependent.

#### Paragraph After Table 3 7 Cont

In the standard, neither BCD data types nor counter data types are defined. BCD code is not nearly as important now as in the past and must therefore be defined individually for special purposes in a PLC system. Counter values are implemented by normal integers, no specific format is required at least for the standard counter function blocks of IEC 61131-3.
In Appendix D all data types are listed together with their properties (range, initial values). Examples of data types have already been given in Table 3.2.

### Subsection 3 4 2

#### Title

3.4.2 Derived data types (type definition)

#### Paragraphs

- On the basis of the elementary data types, PLC programmers can create their own, “user-defined” data types. This procedure is known as derivation or type definition. This enables programmers to implement the data model most favourable for their application.
- Such type definitions are global for a PLC project. The data types defined with new names are called derived data types and are used for variable declarations in the same way as the elementary data types.
- Textual representation has to be employed for type definitions. IEC 61131-3 does not mention graphical representation.
- Type definitions are framed by the keywords TYPE ... END_TYPE, as shown in Example 3.6.

#### Example 3 6

##### Code

TYPE
LongFloatNum : LREAL; (_ direct derivation from IEC data type _)
FloatingPoint : LongFloatNum; (_ direct derivation from a user-defined data type _)
InitFloatNum : LREAL := 1.0; (_ derivation with new initial value _)
tControl : BOOL := TRUE; (_ derivation with new initial value _)
END_TYPE

##### Caption

Example 3.6. Example of simple type definitions: “direct derivation” of a data type

#### Paragraphs After Example 3 6

- In Example 3.6 the new data type LongFloatNum is defined as an alternative for the standard data type LREAL. After this declaration, LongFloatNum and LREAL can be used equivalently for further variable declarations.
- As the example shows, a derived data type can in turn serve as the basis for a further derivation. Therefore FloatingPoint is also equivalent to LREAL. The derived data type InitFloatNum has a different initial value to LREAL, 1.0 instead of 0.0. Furthermore tControl has the initial value TRUE as opposed to the standard initial value FALSE.
- Type definitions are required in order to create new data types with extended or different properties which can be passed on by repeated use.
- A task to be programmed can be implemented more effectively by the use of such application-orientated data types. Customers and PLC manufacturers can create or predefine individual data types:
- -Initial values deviating from the standard, -Data types for range and enumeration, -Multidimensional arrays, -Complex data structures.
- These possibilities can be combined with each other and are supported by IEC 61131-3. They are explained further in the following sections.

#### Additional Properties

##### Title

Additional properties for elementary data types.

##### Paragraph 1

The following additional properties can be assigned to an elementary data type as shown in Table 3.8.

##### Table 3 8

| Property      | Meaning                                                                                                                                                      |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Initial value | The variable is given a particular initial value.                                                                                                            |
| Enumeration   | The variable can assume one of a specified list of names as a value.                                                                                         |
| Range         | The variable can assume values within the specified range.                                                                                                   |
| Array         | Several elements of the same data type are combined into an array. While accessing the array the maximal permissible subscript (index) must not be exceeded. |
| Structure     | Several data types are combined to form one data type. A structured variable is accessed using a period and the component name.                              |

##### Caption Table 3 8

Table 3.8. Additional properties for elementary data types

##### Paragraphs After Table 3 8

- The properties “array” and “structure” can also be applied to derived data types, i.e. they can be nested. Multiple arrays of a particular data type form a multi dimensional array type.
- The “range” property is defined in IEC 61131-3 only for the elementary data type Integer and its direct derivatives. An extension to further data types is conceivable.
- An enumerated data type is not a derivative in the true sense since it is not derived from any elementary data type. But in IEC 61131-3 it is defined as such, as the programming system typically uses integers to implement enumerated data types, thus giving the impression of derivation.
- The examples in Example 3.7 show the use of these additional properties: Colour can be the range of values for a traffic light with three colours, Sensor contains a permissible temperature range and the array Measure is suitable for 45 single measurements. TestBench is a data structure made up of elementary and derived data types.

##### Example 3 7

###### Code

TYPE
Colour : (red, yellow, green); (_ enumeration _)
Sensor : INT (-56..128); (_ range _)
Measure : ARRAY [1..45] OF Sensor; (_ array _)
TestBench : (_ structure _)
STRUCT
Place : UINT; (_ elementary data type _)
Light : Colour:= red; (_ enumerated data type with initial value _)
Meas1 : Measure; (_ array type _)
Meas2 : Measure; (_ array type _)
Meas3 : Measure; (_ array type _)
END_STRUCT;
END_TYPE

###### Caption

Example 3.7. Examples of elementary data types with additional properties as derived data types

##### Paragraphs After Example 3 7

- Compliance with the properties in Table 3.8 for range and array subscript (index) can be checked both statically (by the programming system) and dynamically (at run time).
- The assignment of properties helps in the detection of bugs while creating programs and at run time, leading to more secure programs as well as improving the program documentation.
- The three elements in parentheses for the enumerated data type are entered as names by the programmer without any further information being necessary. They can therefore be understood as “text constants”.
- The programming system automatically converts the three values red, yellow and green, for example, into suitable code. The values are usually internally mapped, invisibly for the programmer, to integer values, for example, beginning with “1”. In the program the names of the colour values can be employed directly as constants. In Example 3.7 the variable for Light receives “red” as the initial value.
- The use of enumerated data types simplifies automatic checking by the programming system. It also makes the programs easier to read.
- If a range is declared for a data type, as for Sensor in Example 3.7, an error is reported if this range is exceeded during programming or at run time.
- Ranges can also be used in CASE statements in the ST language in order to carry out range-dependent tasks, see Section 4.2.6.

#### Arrays

##### Title

Arrays.

##### Paragraphs

- Arrays are directly consecutive data elements of the same data type in memory. An array element can be accessed with the aid of an array subscript (index) within the specified array limits. The value of the subscript indicates which array element is to be addressed. This is illustrated by Figure 3.1.
- Powerful PLC systems ensure that an error message will be issued at run time if an attempt is made to access an array with an array subscript outside the allowed array limits.

##### Figure 3 1

###### Src

https://storage.googleapis.com/generativeai-downloads/images/82%203%20Variables%2C%20Data%20Types%20and%20Common%20Elements.jpg

###### Alt

Figure 3.1. Illustration of the elements of a one-dimensional array

###### Title

Figure 3.1. Illustration of the elements of a one-dimensional array

##### Paragraphs After Figure 3 1

- The array shown in Figure 3.1 is one-dimensional i.e. it has precisely one set of array limits. Multidimensional arrays may also be created by declaring further sets of array limits separated by commas, as shown in Example 3.8 (Meas_2Dim). In this case the elements are stored in memory one dimension after the other. The dimensions are specified in order of significance.

##### Example 3 8

###### Code

TYPE
Meas_1Dim : ARRAY [1..45] OF Sensor; (_ 1-dimensional array _)
Meas_2Dim : ARRAY [1..10,1..45]OF Sensor; (_ 2-dimensional array _)
END_TYPE

###### Caption

Example 3.8. Type definitions of a one-dimensional and two-dimensional array for the acquisition of one (Meas_1Dim) or of ten (Meas_2Dim) logged measurements.

##### Paragraph After Example 3 8

Arrays of FB instance names are not allowed in IEC 61131-3. This would nevertheless be a reasonable extension of the standard in order to enable, for example, easier access to similar timers and counters.
In addition to the definition of arrays as a data type, arrays can also be defined directly with the variable declaration. This is explained in Section 3.5. Examples of the practical use of variables of these data types are also given.

#### Data Structures

##### Title

Data structures.

##### Paragraphs

- With the aid of the keywords STRUCT and END_STRUCT, data structures -known and used in high-level programming languages (e.g. struct { } in the programming language C) -can be built up hierarchically. These may contain any elementary or derived data types as sub-elements. FB instance names are similarly not allowed in data structures, although there is room here for a possible extension to IEC 61131-3.
- If a sub-element is also a structure, a structure hierarchy is created (as illustrated by Figure 3.2), whose lowest structure level may consist of elementary or derived data types.

##### Figure 3 2

###### Src

https://storage.googleapis.com/generativeai-downloads/images/3.4%20Data%20Types%2083.jpg

###### Alt

Figure 3.2. Illustration of a structure (STRUCT). It consists of (multiple) derived and/or elementary data types. The complexity of the data types increases from right to left.

###### Title

Figure 3.2. Illustration of a structure (STRUCT). It consists of (multiple) derived and/or elementary data types. The complexity of the data types increases from right to left.

##### Paragraphs After Figure 3 2

- In this way PLC programmers can optimally adapt their data structures to meet their requirements.
- In Example 3.9 the structure MotorState created to reflect the real operating condition of a controlled motor is defined. For the definition elementary data types (including Revolutions with a range specification) as well as an enumerated type (Level) are used.

##### Example 3 9

###### Code

TYPE
LimitedRevol : UINT (0..230);
TypLevel : (Idling, SpeedUp1, SpeedUp2, MaxPower);
MotorState :
STRUCT
Revolutions : LimitedRevol; (_ range _)
Level : TypLevel; (_ enumerated data type _)
MaxReached : BOOL; (_ elementary data type _)
Failure : BOOL; (_ elementary data type _)
Brake : BYTE; (_ elementary data type _)
END_STRUCT;
END_TYPE

###### Caption

Example 3.9. Type definition of a complex structure as a derived data type based on elementary data types as well as on range specification and enumeration

##### Paragraph After Example 3 9

The new data type MotorState can be used for declaring corresponding variables. For example, in order to describe several motors of the same type an array can be formed (as a variable or also as a data type) consisting of elements with type MotorState.

##### Example 3 10

###### Code

TYPE
MultiMotState : ARRAY [1..4] OF MotorState; (_ further derivation _)
END_TYPE

VAR
(_ case 1: _)
Motor1 : MotorState; (_ declaration _)
(_ case 2: _)
Motors : ARRAY [1..4] OF MotorState; (_ array declaration _)
(_ case 3: _)
FourMotors : MultiMotState; (_ declaration _)
END_VAR

###### Caption

Example 3.10. Use of a derived data type for further derivation (top) and array declaration (bottom)

##### Paragraphs After Example 3 10

- As Example 3.10 shows, the array with the four elements of type MotorState can be created by a variable declaration: Motors has four elements (case 2).
- Case 3 represents an alternative: here the data type MultiMotState is used. This data type reserves for each variable (such as FourMotors) an array of the same size consisting of four elements based on the further derived data type MotorState.
- The derivation of data types can in principle be nested, i.e. data types can be derived from derived data types. However nesting is illegal if it causes recursion. This can occur, for example, when within a structure another structure already containing this structure is defined.
- Example 3.11 shows a case of illegal nesting.

##### Example 3 11

###### Code

TYPE
StructureA :
STRUCT
Element1 : INT;
Element2 : StructureB;(_ legal: sub structure _)
Element3 : BYTE;
END_STRUCT;
StructureB :
STRUCT
Element1 : LINT;
Element2 : StructureA;(_ illegal: recursive to StructureA _)
Element3 : WORD;
END_STRUCT;
END_TYPE

###### Caption

Example 3.11. Illegal nesting of derived data types: StructureA has a substructure that contains itself (recursive type definition).

##### Paragraph After Example 3 11

Section 3.5 gives further examples of the practical use of relevant variables.

#### Initial Values in Type Definitions

##### Title

Initial values in type definitions.

##### Paragraphs

- When defining a data type the programmer can assign initial values which can automatically be inserted in the relevant variable declaration. If, as in Example 3.6, values other than the default initial values specified in IEC 61131-3 are explicitly used in a variable declaration (even for individual structure elements), these values will be used in preference by the programming system.
- The initial values for the data types of IEC 61131-3 are given in Appendix D.

##### Example 3 12

###### Code

TYPE
MotorState :
STRUCT
Revolutions : LimitedRevol := 0;
Level : TypLevel := Idling;
MaxReached : BOOL := FALSE;
Failure : BOOL := FALSE;
Brake : BYTE := 16#FF;
END_STRUCT;
END_TYPE

###### Caption

Example 3.12. Type definition of the structure in Example 3.9 with assignment of initial values (shown in bold type)

##### Paragraphs After Example 3 12

- In Example 3.12 the structure elements of the derived data type MotorState from Example 3.9 are provided with initial values.
- For initial values of arrays, a series of value assignments can be abbreviated by specifying a repeat factor and a sub-series in brackets.
- In the case of data type STRING an initial character string may be specified in single quotation marks.

##### Example 3 13

###### Code

VAR
Field1 : ARRAY [1..12] OF SINT := [3,16#FF,-5,-9,-5,-9,-5,-9,-5,-9,0,0];
Field2 : ARRAY [1..12] OF SINT := [3,16#FF, 4(-5,-9), 2(0)];
Text : STRING [4] := 'stop';
END_VAR

###### Caption

Example 3.13. Example of initialisation of array variables and character strings

##### Paragraph After Example 3 13

In Example 3.13 the two arrays Field1 and Field2 are initialised with the same initial values. For Field2 the shortened form with a repeater before the sub-series (-5,-9) and (0) is used.

### Subsection 3 4 3

#### Title

3.4.3 Generic data types

#### Paragraphs

- IEC 61131-3 defines so-called generic data types in order to hierarchically combine the elementary data types into individual groups. These data types begin with the prefix ANY; e.g. all integer data types (INT) are designated as ANY_INT.
- Many standard functions of IEC 61131-3 can be applied to more than one data type. Addition (ADD) can be carried out, for example, with all types of integers (INT) i.e. ADD supports the generic data type ANY_INT.
- Generic data types are used to describe standard functions in order to specify which of their input or output variables allow several data types. This concept is called overloading of functions and is described in Section 5.1.1.
- Table 3.9 shows how elementary data types are assigned to generic data types. The data type ANY here forms the widest generalisation of a data type.
- If, for example, the standard function for multiplication (MUL) supports the generic data type ANY_NUM, then the programming system permits all data types for MUL which are included in the data types ANY_INT and ANY_REAL i.e. all integers with and without signs as well as floating-point numbers.

#### Table 3 9

| ANY DERIVED | ANY ELEMENTARY | ANY BIT                        | ANY MAGNITUDE                     | ANY DATE                         | ANY STRING      | ANY INT                                          | ANY REAL    |
| ----------- | -------------- | ------------------------------ | --------------------------------- | -------------------------------- | --------------- | ------------------------------------------------ | ----------- |
| -           | -              | -                              | -                                 | -                                | -               | -                                                | -           |
| -           | -              | BOOL, BYTE, WORD, DWORD, LWORD | ANY_NUM (ANY_INT, ANY_REAL), TIME | DATE, TIME_OF_DAY, DATE_AND_TIME | STRING, WSTRING | -                                                | -           |
| -           | -              | -                              | -                                 | -                                | -               | SINT, INT, DINT, LINT, USINT, UINT, UDINT, ULINT | REAL, LREAL |

#### Caption Table 3 9

Table 3.9. Overview of the generic data types ANY

#### Paragraphs After Table 3 9

- The user-defined (derived) data types are also covered by the type ANY. For directly derived data types the generic data type of a variable is the same as that of the derived data type. In Example 3.6 the two data types LongFloatNum and FloatingPoint have the same data type LREAL.
- Generic data types are used to explain the calling interface of (standard) functions and belong to the reserved keywords. Their use in user-defined POUs for variable declaration, for example, is illegal or at least not covered by the standard.

## Section 3 5

### Title

3.5 Variables

### Paragraph 1

As already described in Section 3.3, variables are declared together with a data type as placeholders for application-specific data areas. Their properties can be defined in the declaration by means of:

### Variable Properties List

- Properties of the specified (elementary or derived) data type,
- Information about additional initial values,
- Information about additional array limits (array definition),
- Variable type of the declaration block in which the variable is declared (with attribute/qualifier).

### Example 3 14

#### Code

VAR_OUTPUT RETAIN
RetentiveVar : BYTE := 61;
END_VAR
Variable type Attribute (qualifier)
Variable name Data type Initial value
End of variable type

#### Caption

Example 3.14. Elements of a variable declaration with initial value assignment

### Paragraphs After Example 3 14

- In this example, the variable RetentiveVar of the data type BYTE is declared with the initial value 61.Because it has the qualifier RETAIN it is stored in the battery backed part of the PLC memory.
- The declaration of an instance name for function blocks represents a special case of variable declaration: An FB instance name is declared just like a variable, except that the FB type name is specified in place of the data type, as already described in Section 2.4.1.
- As in the case of type definitions, initial values and arrays can also be defined at the time of declaration with an “unnamed” type definition (see examples in Section 3.5.2). IEC 61131-3 does not provide this facility for the properties enumeration, range and structure.

### Subsection 3 5 1

#### Title

3.5.1 Inputs, outputs and flags as special variables

#### Paragraphs

- The familiar PLC terms inputs, outputs and flags are given special treatment in the IEC variable concept. A short introduction has already been given in Section 3.3.1.
- In order to directly access the data areas of the PLC system’s processors and their I/O modules in the program, IEC 61131-3 offers the PLC programmer two possibilities:
- -Directly represented variables, -Symbolic variables.
- In the declaration of such variables the physical memory location (PLC address, e.g. the I/O module address) is specified with the keyword AT. The address structure is shown in Table 3.10. These direct PLC addresses are also called hierarchical addresses.
- They begin with a “%”, followed by a letter I (input), Q (output) or M (flag/memory). This is followed by another letter, which indicates the data width of the PLC address. “X” (bit address) can also be omitted.

#### Table 3 10

| Direct PLC Addresses | Explanations                                                                                                                                                                                                          |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| %                    | introductory character                                                                                                                                                                                                |
| I                    | input                                                                                                                                                                                                                 |
| Q                    | output                                                                                                                                                                                                                |
| M                    | flag/memory                                                                                                                                                                                                           |
| none                 | bit                                                                                                                                                                                                                   |
| X                    | bit (optional)                                                                                                                                                                                                        |
| B                    | byte                                                                                                                                                                                                                  |
| W                    | word                                                                                                                                                                                                                  |
| D                    | double word                                                                                                                                                                                                           |
| L                    | long word                                                                                                                                                                                                             |
| \*                   | memory location, not (yet) defined                                                                                                                                                                                    |
| v.w.x.y.z            | multi-digit hierarchical address, increasing in significance from right to left. The number and interpretation of the places are dependent on the manufacturer, e.g.: z - bit, y - word, x - module, w - bus, v - PLC |
| Examples             | -                                                                                                                                                                                                                     |
| %IW7                 | input word 7                                                                                                                                                                                                          |
| %QD3.1               | output double word 1 in module 3                                                                                                                                                                                      |
| %M5.2.0              | flag 0 of word 2 of module 5                                                                                                                                                                                          |
| %MX5.2.0             | flag 0 of word 2 of module 5                                                                                                                                                                                          |
| %I80                 | input bit 80                                                                                                                                                                                                          |
| %QB4                 | output byte 4                                                                                                                                                                                                         |
| %Q\*                 | output at storage location that has not yet been defined                                                                                                                                                              |

#### Caption Table 3 10

Table 3.10. Structure of the direct PLC addresses with examples. They are used for the declaration of “directly represented” and “symbolic” variables.

#### Paragraphs After Table 3 10

- In the case of directly represented variables, a data type is assigned to a hierarchical address (see Example 3.15). The declaration of symbolic variables also contains a variable name with which the desired input, output or flag can be accessed “symbolically”.

#### Example 3 15

##### Code

VAR
(_ directly represented variable _)
AT %IW6 : WORD; (_ input word starting at address 6 _)
AT %QD3 : DINT; (_ output double word starting at address 3 _)
(_ Symbolic variable _)
OUT_HG AT %QW7: WORD; (_ output word 7 at address 7_)
AD_3 AT %QD3: DINT; (_ output double word at address 3 _)
C2 AT %Q*: BYTE; (* assignment C2 to output storage location*)
END_VAR
...
LD %IW6 (* use of a directly represented variable _)
ST OUT_HG (_ use of a symbolic variable \*)
...

##### Caption

Example 3.15. Examples of directly represented and symbolic variables and their use in IL with the aid of hierarchical addresses

#### Paragraphs After Example 3 15

- Assigning a data type to a flag or I/O address enables the programming system to check whether the variable is being accessed correctly. For example, a variable declared by “AT %QD3 : DINT;” cannot be inadvertently accessed with UINT or REAL.
- Directly represented variables replace the direct PLC addresses often employed in programs up until now (e.g. I 1.2). In this case, the address also acts as the variable name (like %IW6 in Example 3.15).
- Symbolic variables are declared and used in the same way as normal variables, except that their storage location cannot be freely assigned by the programming system, but is restricted to the address specified by the user with “AT” (like OUT_HG in Example 3.15). These variables correspond to addresses which were previously assigned symbolic names via an assignment list or symbol table.
- When an asterisk is used in programs and functions blocks to mark undefined storage locations, this must be done in configurations using VAR_CONFIG … END_VAR, see also Chapter 6.
- Directly represented and symbolic variables may be declared for the variable types VAR, VAR_GLOBAL, VAR_EXTERNAL and VAR_ACCESS in programs, resources and configurations. In function blocks they can only be imported with VAR_EXTERNAL.

### Subsection 3 5 2

#### Title

3.5.2 Multi-element variables: arrays and structures

#### Paragraphs

- IEC 61131-3 designates arrays and structures as multi-element variables. Accordingly, simple variables are designated as single-element variables. The type definitions of the multi-element variables have already been discussed in Section 3.4.2. Their use is described below.
- Example 3.16 shows arrays and structures employing the type definitions of Example 3.9 and Example 3.10.

#### Example 3 16

##### Code

TYPE
LineState :
STRUCT
Running : BOOL;
Drive : MultiMotState;
END_STRUCT;
END_TYPE
VAR
Input AT %IB0 : ARRAY [0..4] OF BYTE;
Index : UINT := 5;
Motor1 : MotorState;
FourMotors : MultiMotState;
MotorArray : ARRAY [0..3, 0..9] OF MotorState;
Line : ARRAY [0..2] OF LineState;
END_VAR

##### Caption

Example 3.16. Examples of multi-element variable declarations

#### Paragraphs After Example 3 16

- Data elements of an array are accessed by selecting the integer array subscript (e.g. Index) in square brackets. Structure elements are addressed by specifying the structure’s variable name, followed by a period and the name of the structure component.
- Table 3.11 shows access examples to single-element and multi-element variables from Example 3.16.

#### Table 3 11

| Access to Array Elements | Remarks                                   | Access to Structure Elements |
| ------------------------ | ----------------------------------------- | ---------------------------- |
| Input [0]                | first input element                       | -                            |
| FourMotors [Index]       | the 4th structure, if index is 4          | -                            |
| MotorArray [Index, 2]    | 34 th structure MotorState, if index is 3 | -                            |
| -                        | component Revolutions                     | Motor1.Revolutions           |
| -                        | component Revolutions of 2nd structure    | FourMotors[1].Revolutions    |
| -                        | -                                         | MotorArray[Index, 2].Level   |
| -                        | -                                         | Line[1].Drive[1].Revolutions |

#### Caption Table 3 11

Table 3.11. Examples of use of the multi-element variables in Examples 3.16, 3.9 and 3.10 - access to arrays and structures

#### Paragraph After Table 3 11

In Example 3.10 an array was defined within a data type. As Example 3.16 shows in the case of Input or the two-dimensional array MotorArray, an array definition can also be specified within a variable declaration.
Array definition is not defined or planned within IEC 61131-3 for the enumerated data type or for ranges or data structures, but this would be a helpful extension to the standard.

#### Paragraph After Table 3 11 Cont

As Table 3.11 shows, the accesses with array subscript and period can be nested for complex variables with substructures, as illustrated by the variable Line.
Initial values can be defined in variable declarations for single- and multi-element variables according to the same rules as shown in Example 3.12 and Example 3.13 for type definitions.

### Subsection 3 5 3

#### Title

3.5.3 Assignment of initial values at the start of a program

#### Paragraphs

- Variables are assigned initial values when the resource or the configuration is started (see also Chapter 6). These initial values are dependent on the information specified by the PLC programmer in the corresponding declaration part for the variable or on the values specified for the relevant data type.
- Since elementary data types (and therefore also those derived from them) have predefined default initial values, it is guaranteed that every variable has defined initial values.
- A variable can assume initial values according to the rules shown in Table 3.12. However, the extent to which these rules can be used is typically dependent on the implementation by the programming system.

#### Table 3 12

| Default                      | Prior.a                   | Program Start                                                                                          | Remarks                                                                                                                                                                                                                           |
| ---------------------------- | ------------------------- | ------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Battery-backed with RETAIN   | <pre><code>1</code></pre> | Warm restart:<br>Restoration of the values after power recovery or after stop (warm reboot).           | -                                                                                                                                                                                                                                 |
| Initial value in declaration | <pre><code>2</code></pre> | Cold restart:<br>Initial values for a defined new start of the program, as well as after program load. | These values are specified in the variable declaration.                                                                                                                                                                           |
| Initial value from data type | <pre><code>3</code></pre> | -                                                                                                      | Elementary data types are initialised with 0 for numerical values and times, 01-01-01 for date and an empty character string for strings.<br>For derived data types individual initial values can be used in the type definition. |

#### Table 3 12 Footnote

a Priority: 1=highest priority, 3= lowest priority

#### Caption Table 3 12

Table 3.12. Assignment of initial values according to priorities on warm and cold restart. The three possible ways of assigning initial values to variables are shown in the left-hand column.

#### Paragraphs After Table 3 12

- If several methods of assigning initial values to variables are used, the one with the highest priority applies at a warm or cold restart. On warm restart a retained value has priority over the initial values specified in the variable declaration or type definition. The initial value for the data type is only employed if neither retentiveness nor an initial value is specified in the variable declaration.
- If a PLC program is started by a warm restart (power recovery), its retentive variables retain the values they held before the interruption occurred. This behaviour is also known as warm reboot.
- After a cold restart (after loading of the program into the PLC or after a stop through errors or the user), the variables are set to the initial values assigned in the definition of the data type (predefined or user-defined) or in the (user-defined) variable declaration (New start).
- The initialisation of the inputs and outputs of a PLC system (I/O modules) and other memory areas is implementation-dependent.
- Initial values are permissible for every variable type except for VAR_IN_OUT and VAR_EXTERNAL. External variables are initialised where they are declared as global -in the relevant VAR_GLOBAL. In the case of VAR_IN_OUT, initialisation is not allowed since this variable type declares pointers to variables and not the variables themselves.

### Subsection 3 5 4

#### Title

3.5.4 Attributes of variable types

#### Paragraph 1

IEC 61131-3 defines attributes, or qualifiers, with which additional properties can be assigned to variables:

#### Attributes List

- RETAIN Retentive variable (battery back-up)
- NON_RETAIN Non-retentive variable (no battery back-up)
- CONSTANT Constant variable (cannot be modified)
- R_EDGE Rising edge
- F_EDGE Falling edge
- READ_ONLY Write-protected
- READ_WRITE Can be read and written to

#### Paragraphs After List

- The RETAIN, NON_RETAIN and CONSTANT qualifiers in IEC 61131-3 are specified immediately after the keyword of the variable type. This means that these three qualifiers always refer to the entire section of the variable declaration (up to END_VAR).
- The four other attributes, or qualifiers, are assigned individually for individual variable declarations and cannot be combined with the other three qualifiers.
- Table 3.13 shows the variable types for which these attributes/qualifiers are permissible.

#### Table 3 13

| Variable Type | RETAIN NON RETAIN | CONSTANT | R EDGE, F EDGE | READ ONLY, READ WRITE |
| ------------- | ----------------- | -------- | -------------- | --------------------- |
| VAR           | yes               | yes      | no             | no                    |
| VAR_INPUT     | yes               | no       | ja             | no                    |
| VAR_OUTPUT    | yes               | no       | no             | no                    |
| VAR_IN_OUT    | no                | no       | no             | no                    |
| VAR_EXTERNAL  | no                | yes      | no             | no                    |
| VAR_GLOBAL    | yes               | yes      | no             | no                    |
| VAR_ACCESS    | no                | no       | no             | yes                   |
| VAR_TEMP      | no                | yes      | yes            | no                    |
| VAR_CONFIG    | no                | no       | no             | no                    |

#### Caption Table 3 13

Table 3.13. Use of attributes/qualifiers for variable types

#### Paragraphs After Table 3 13

- RETAIN is used to indicate retentive variables, i.e. variables whose values are to be retained during a loss of power. NON_RETAIN has the opposite effect, i.e. variables are explicitly not to be retained. The state of variables without the attribute RETAIN or NON_RETAIN after a loss of power is implementation dependent, see also Table 3.12.
- The attributes RETAIN and/or NON_RETAIN are permitted for VAR, VAR_INPUT, VAR_OUTPUT and VAR_GLOBAL and meaningful for retaining variables in an instance of function blocks or programs or retaining instances of structured variable types. They are, however, not permitted for individual elements of structures.
- CONSTANT describes “variables” whose values are not allowed to be changed during program execution, i.e. they are to be treated as write-protected constants (not variables).
- The qualifier CONSTANT is permitted for the variable types VAR, VAR_EXTERNAL and VAR_GLOBAL. Constants, which are declared as global, must also be declared as constants when used externally.
- The simultaneous use of RETAIN and CONSTANT makes no sense and is not permitted by IEC 61131-3 because constants must always be restored (statically) in the PLC after a power failure, thus making the RETAIN qualifier superfluous.
- The qualifiers R_EDGE and F_EDGE indicate Boolean variables which can recognise rising or falling edges. They are permitted by IEC 61131-3 exclusively for the variable type VAR_INPUT. However, it is also conceivable to extend this mechanism to the variable types VAR and VAR_GLOBAL. Edge detection is performed implicitly by standard function blocks of IEC 61131-3 and is described in detail in Section 5.2.
- The attributes READ_ONLY and READ_WRITE are reserved exclusively for the variable type VAR_ACCESS, (see also Chapter 6). No other qualifiers are permitted for VAR_ACCESS at the configuration level.

#### Example 3 17

##### Code

VAR_OUTPUT RETAIN
RetentiveVar : BYTE;
END_VAR
VAR CONSTANT
ConstantNum : BYTE := 16#FF;
END_VAR
VAR_INPUT
FallingEdge : BOOL F_EDGE;
END_VAR
VAR_ACCESS
LineEmpty : CPU_LINE.%IX1.0 : BOOL READ_ONLY;
END_VAR

##### Caption

Example 3.17. Examples of the use of attributes/qualifiers with different variable types (shown in bold type)

### Subsection 3 5 5

#### Title

3.5.5 Graphical representation of variable declarations

#### Paragraphs

- The declaration part of POUs -as well as the code part -can be programmed both in graphical and in textual form. The graphical representation is used for better visualisation of the call interface and of the POU return values with their input and output variables.
- The graphical facilities defined by IEC 61131-3 are adequate for simple variable declarations of the POU interface, but for declaration of arrays, retentive variables or initial values the textual representation must be used.
- Table 3.14 shows which variable types and attributes of a POU can be represented (and therefore also declared) graphically as well as textually.

#### Table 3 14

| Category                       | Item                  | Graphical Representation |
| ------------------------------ | --------------------- | ------------------------ |
| Variable types                 | VAR                   | no                       |
| -                              | VAR_INPUT             | yes                      |
| -                              | VAR_IN_OUT            | yes                      |
| -                              | VAR_OUTPUT            | yes                      |
| -                              | VAR_EXTERNAL          | no                       |
| -                              | VAR_GLOBAL            | no                       |
| -                              | VAR_ACCESS            | no                       |
| Attributes with variable types | RETAIN, NON_RETAIN    | no                       |
| -                              | CONSTANT              | no                       |
| -                              | R_EDGE, F_EDGE        | yesa                     |
| -                              | READ_ONLY, READ_WRITE | no                       |

#### Table 3 14 Footnote

a Planned only for variable type VAR_INPUT

#### Caption Table 3 14

Table 3.14. Graphical representation for variable types and their attributes

#### Paragraphs After Table 3 14

- Example 3.18 shows a declaration part in graphical representation with some of the possibilities specified in Table 3.14, as well as the textual version.
- The graphical representation of the qualifiers RETAIN and CONSTANT and the other attributes is not dealt with in IEC 61131-3. This could, however, be implemented additionally for a programming system. Graphical representation of all variable types is also conceivable.
- As illustrated in Example 3.18, the graphical representation of declarations visualises the calling interface (formal parameters) and return values of POUs.

#### Example 3 18

##### Code

Graphical:
BOOL Inp -->| |
BOOL InOut <-->| |--> BOOL
BOOL Inp1 -->| |
BOOL Inp2 -->| |--> BOOL Out

Textual:
VAR_INPUT
Inp : BOOL;
Inp1 : BOOL R_EDGE;
Inp2 : BOOL F_EDGE;
END_VAR
VAR_OUTPUT
Out : BOOL;
END_VAR
VAR_IN_OUT
InOut : BOOL;
END_VAR

##### Caption

Example 3.18. Graphical and textual representation of the declaration part. Edge detection is symbolised by “>” and “<”, VAR_IN_OUT with a continuous line.

#### Paragraph After Example 3 18

The call of a POU can also be represented graphically. In this case, the actual parameters are assigned to the formal parameters and the return values are processed further.
This results in a uniform graphical view of the declaration and invocation of a POU, as shown for function block IO_Exam in Example 3.19.

#### Example 3 19

##### Code

Declaration (left):
FUNCTION_BLOCK IO_Exam
INT Inp1 -->| |--> BYTE Out1
BOOL Inp2 -->| |--> BYTE Out2
END_FUNCTION_BLOCK
formal parameters return values

Invocation (right):
InstanceName
IO_Exam
Count -->|Inp1 Out1|--> Result1
EmergOff -->|Inp2 Out2|--> Result2
actual parameters further processing

##### Caption

Example 3.19. Formal parameters and return values in the FB declaration (left) and supply of actual parameters in the FB invocation as well as further processing of the results (right)

#### Paragraph After Example 3 19

For an explanation of formal parameters and return values see also Section 2.3.2.
