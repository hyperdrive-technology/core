# Appendix C

## Title

C IL Examples

## Introduction

- This appendix contains full examples of PLC programming with IEC 61131-3 for each type of POU, to supplement the information given in Chapters 2 and 4.
- These examples are to be found on the CD enclosed in this book.

## Section C 1

### Title

C.1 Example of a FUNCTION

### Paragraph 1

The function ByteExtr extracts the upper or lower byte of an input word and returns it as the function value:

### Example C 1

#### Code

FUNCTION ByteExtr : BYTE (_ extract byte from word _)
(_ beginning of declaration part _)
VAR_INPUT (_ input variables _)
DbByte : WORD; (_ word consists of upper + lower byte _)
Upper : BOOL; (_ TRUE: take upper byte, else lower _)
END_VAR
(_ beginning of instruction part _)
LD Upper (_extract upper or lower byte? _)
EQ FALSE (_ lower? _)
JMPCN UpByte (_ jump in the case of extraction of the upper byte _)
LD DbByte (_ load word _)
WORD_TO_BYTE (_ conversion for type compatibility _)
ST ByteExtr (_ assignment to the function value _)
RET (_ nothing to do _)
UpByte: (_ jump label _)
LD DbByte (_ load word _)
SHR 8 (_ shift upper byte 8 bits to the right _)
WORD_TO_BYTE (_ conversion for type compatibility _)
ST ByteExtr
RET (_ return with function value in CR _)
(_ end of FUN _)
END_FUNCTION

#### Caption

Example C.1. Example of the declaration of a function in IL

### Paragraphs After Example C 1

- The ByteExtr function in Example C.1 has the input parameter DbByte of type WORD and the Boolean input Upper. The value returned by the function is of type BYTE. This function requires no local variables. The VAR ... VAR_END section is therefore missing from the declaration part.
- The returned value is in the current result (CR) when the function returns to the calling routine with RET. At this point (jump label End:) the CR is of data type WORD, because DbByte was previously loaded. The function value is of data type BYTE after type conversion.
- IEC 61131-3 always requires a strict "type compatibility" in cases like this. It is the job of the programming system to check this consistently. This is why a standard type conversion function (WORD_TO_BYTE) is called in Example C.1.
- Example C.2 shows the instruction part of ByteExtr in the ST programming language.

### Example C 2

#### Code

FUNCTION ByteExtr : BYTE (_ extraction byte from word _)
VAR_INPUT ... END_VAR (_ as above _)
IF Upper THEN
ByteExtr := WORD_TO_BYTE (SHR (DbByte, 8) );
ELSE
ByteExtr := WORD_TO_BYTE (DbByte);
END_IF;
END_FUNCTION

#### Caption

Example C.2. Instruction part of Example C.1 in ST

### Example C 3

#### Code

Graphical Declaration (left):
FUNCTION ByteExtr
WORD DbByte -->| |--> BYTE
BOOL Upper -->| |
END_FUNCTION

Graphical Call (right):
%MW4 -->|ByteExtr DbByte|--> %MB4
TRUE -->| Upper|

#### Caption

Example C.3. Graphical declaration part of the function declaration in Example C.1 (left) with an example of a call (right)

### Paragraph After Example C 3

Example C.3 shows the declaration part and an example of a call for the function ByteExtr in graphical representation. The call replaces the lower byte of flag word %MW4 by its upper byte.

## Section C 2

### Title

C.2 Example of a FUNCTION_BLOCK

### Paragraph 1

The function block DivWithRem calculates the result of dividing two integers and returns both the division result and the remainder. "Division by zero" is indicated by an output flag.

### Example C 4

#### Code

FUNCTION_BLOCK DivWithRem (_ division with remainder _)
(_ beginning of declaration part _)
VAR_INPUT (_ input parameter _)
Dividend : INT; (_ integer to be divided _)
Divisor : INT; (_ integral divisor _)
END_VAR
VAR_OUTPUT RETAIN (_ retentive output parameters _)
Quotient : INT; (_ result of the division _)
DivRem : INT; (_ remainder after division _)
DivError : BOOL; (_ flag for division by zero _)
END_VAR
(_ beginning of instruction part _)
LD 0 (_ load zero _)
EQ Divisor (_ divisor equal to zero? _)
JMPC Error (_ catch error condition _)
LD Dividend (_ load dividend, divisor not equal to zero _)
DIV Divisor (_ carry out division _)
ST Quotient (_ store integral division result _)
MUL Divisor (_ multiply division result by divisor _)
ST DivRem (_ store interim result _)
LD Dividend (_ load dividend _)
SUB DivRem (_ subtract interim result _)
ST DivRem (_ yields "remainder" of the division as an integer_)
LD FALSE (_ load logical "0“ for error flag _)
ST DivError (_ reset error flag _)
JMP End (_ ready, jump to end _)
Error: (_ handling routine for error "division by zero" _)
LD 0 (_ zero, since outputs are invalid in event of error _)
ST Quotient (_ reset Result _)
ST DivRem (_ reset Remainder _)
LD TRUE (_ load logical "1“ for error flag _)
ST DivError (_ set error flag _)
End:
RET
(_ end of FB _)
END_FUNCTION_BLOCK

#### Caption

Example C.4. Example of the declaration of a function block in IL

### Paragraph After Example C 4

The FB DivWithRem in Example C.4 performs integer division with remainder on the two input parameters Dividend and Divisor. In the case of division by zero, the error output DivError is set and the other two outputs are set in a defined manner to zero since they are invalid. The outputs are retentive, i.e. they are retained within the FB instance from which DivWithRem was called.
This example can also be formulated as a function because no statistical information has to be retained between calls.
Example C.5 shows the instruction part of DivWithRem in the ST programming language.

### Example C 5

#### Code

FUNCTION_BLOCK DivWithRem (_ division with remainder _)
VAR_INPUT ... END_VAR (_ as above _)
VAR_OUTPUT RETAIN ... END_VAR
IF Divisor = 0 THEN
Quotient := 0;
DivRem := 0;
DivError := TRUE;
ELSE
Quotient := Dividend / Divisor;
DivRem := Dividend - (Quotient \* Divisor);
DivError := FALSE;
END_IF;
END_FUNCTION_BLOCK

#### Caption

Example C.5. Instruction part of Example C.4 in ST

### Example C 6

#### Code

Graphical Declaration (top):
FUNCTION_BLOCK DivWithRem
INT Dividend -->| |--> INT Quotient
INT Divisor -->| |--> INT DivRem
| |--> BOOL DivError
END_FUNCTION_BLOCK

Graphical Call (bottom):
DivInst
DivWithRem
100 -->|Dividend Quotient|--> Result
3 -->|Divisor DivRem |--> Remainder
| DivError|--> Error

#### Caption

Example C.6. Graphical declaration part for Example C.4 (top) and example of a call of the FB instance DivInst (bottom)

### Paragraph After Example C 6

Example C.6 shows the declaration part and an example of a call of the function DivWithRem in graphical representation. The FB must be instantiated (DivInst) before it can be called.
After execution of the function block, the output variables of this instance have the following values: DivInst.Quotient = 33, DivInst.DivRem = 1 and DivInst.DivError = FALSE. These return values are assigned to the variables Result, Remainder and Error respectively.

## Section C 3

### Title

C.3 Example of a PROGRAM

### Paragraph 1

The program MainProg in Example C.8 is not a complete programming example, but shows ways of implementing problems and illustrates the use of variables in POUs of type PROGRAM.

### Paragraph 2

MainProg first starts a real-time clock DateTime that records the date and time by using function block RTC. This function block can be either user specific or predefined by manufacturer – since edition 2 of the standard IEC 1131-3 this RTC is not avaliable as a standard FB any longer. Example C.7 shows one possible representation as example. This real-time clock RTC is used to find out how long an interruption in the program has lasted (TimeDiff). The PLC system must be able to detect the interruption (Ress_Running) and must be able to access a hardware clock with an I/O address (ActDateTime).

### Example C 7

#### Code

Graphical:
BOOL -->|RTC EN Q|--> BOOL
DT -->| PDT CDT|--> DT

#### Caption

Example C.7. Graphical representation of example RTC, which is not a standard FB of IEC 1131-3. Rising edge at EN loads the real-time-clock, CDT is current date and time while EN; Q is copy of EN.

### Example C 8

#### Code

PROGRAM MainProg (_ example of a main program _)
VAR_INPUT (_ input variables _)
T_Start : BOOL := FALSE; (_ input starting condition _)
END_VAR
VAR_OUTPUT (_ output variables _)
T_Failure : BOOL := FALSE; (_ output "failure“ _)
END_VAR
VAR_GLOBAL RETAIN (_ global retentive data area _)
Ress_Running AT %MX255.5 : BOOL; (_ running flag for resource/PLC-CPU _)
DateTime : RTC; (_ use buffered clock: date and time _)
ActDateTime AT %MD2 : DT; (_ hardware clock: actual date with time _)
END_VAR
VAR_GLOBAL (_ global data area _)
EmergOff AT %IX255.0 : BOOL; (_ contact Emergency-Off _)
ProgRun : BOOL := FALSE; (_ "running“ flag _)
Error : BOOL; (_ error flag _)
Err_Code : UDINT := 0; (_ Error code, 32 bit unsigned _)
END_VAR
VAR (_ local variables _)
AT %IX250.2 : BOOL; (_ directly represented variables _)
ErrorProc : CErrProc; (_ FB instance of CErrProc _)
Edge : R_TRIG; (_ edge detection _)
TimeDiff : TIME := t#0s; (_ time difference _)
END_VAR
(_ beginning of instruction part _)
LD FALSE
ST Error (_ reset error flag _)
... (_ determine how long a power failure and/or an interruption _)
(_ of the CPU lasted; Clock "DateTime" is battery-backed _)
LD t#0s (_ zero seconds _)
ST TimeDiff (_ reset _)
LD DateTime.Q (_ time valid = clock running _)
JMPC Goon (_ valid - nothing to do _)
LD ActDateTime (_ check current time _)
SUB DateTime.CDT (_ last time before power failure _)
ST TimeDiff (_ duration of power failure _)
Goon:
...
LD Ress_Running (_ CPU is running _)
ST DateTime.IN (_ clock running if CPU is running _)
LD ActDateTime (_ initial value Date/Time _)
ST DateTime.PDT (_ initial value of clock is loaded _)
(_ if there is a rising edge at IN _)
CAL DateTime (_ start real-time clock)
...
LD TimeDiff (_ interruption duration _)
LT t#50m (_ less than 50 seconds? _)
JMPC Continue (_ plant still warm enough ... _)
NOT
S Error (_ set error flag _)
LD 16#000300F2
ST Err_Code (_ store error cause _)
Continue:
LD EmergOff (_ "emergency off“ pressed? _)
ST Edge.CLK (_ input edge detection _)
CAL Edge (_ compare input with edge flag _)
LDN Edge.Q (_ edge at EmergOff recognized? _)
AND T_Start (_ AND start flag set _)
ANDN Error (_ AND no new error _)
AND ErrorProc.Ack (_ AND error cause repaired _)
ST ProgRun (_ global "running“ condition _)
.... (_ ...real instructions, calls of FUN/FBs... _)
LD Error (_ error occurred? _)
AND %IX250.2
R ProgRun (_ reset global starting condition _)
LD ProgRun
JMPCN End (_ in the case of error: start error handler _)
CALC ErrorProc(Code := Err_Code) (_ FB with central error handling _)
LD ErrorProc.Ack (_ flag: error acknowledged _)
End:
LD ProgRun (_ program not running _)
ST T_Failure (_ set output parameter _)
RET (_ return and/or end \*)
END_PROGRAM

#### Caption

Example C.8. Example of the declaration of a main program in IL. The FB CErrProc ("central error processing") must already be available (continued on next page)

### Paragraph After Example C 8

Edge detection is also employed in this program in order to find out whether the Emergency Off button has been pressed.
In the global data area, the variable ProgRun is declared, which is available to all function blocks called under MainProg (as VAR_EXTERNAL). This is linked with the starting condition provided EmergOff has not been pressed.
FB instance ErrProc can handle errors with error code Err_Code. When the error has been corrected and acknowledged, the corresponding output is set to TRUE.

### Example C 9

#### Code

RESOURCE CentralUnit_1 ON CPU_001
TASK Periodic (INTERVAL := time#13ms, PRIORITY := 1);
PROGRAM Applic WITH Periodic : MainProg ( T_Start := %I250.0,
T_Failure => %Q0.5);
END_RESOURCE

#### Caption

Example C.9. Resource definition with run-time program Applic for Example C.8

### Paragraph After Example C 9

The program MainProg is provided with the properties of the periodic task Periodic and becomes the run-time program Applic of the resource (PLC-CPU) CentralUnit_1. This run-time program runs with highest priority (1) as a periodic task with a maximum cycle time of 13 ms.
MainProg is called with the value of input bit %I250.0 for the input variable T_Start and sets output bit %Q0.5 with the value of T_Failure.
