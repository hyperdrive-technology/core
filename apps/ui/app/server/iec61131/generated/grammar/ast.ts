/******************************************************************************
 * This file was generated by langium-cli 3.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const IEC61131Terminals = {
    WS: /\s+/,
    ML_COMMENT: /\(\*[\s\S]*?\*\)/,
    SL_COMMENT: /\/\/[^\n]*/,
    FUNCTION_BLOCK: /FUNCTION_BLOCK/,
    END_FUNCTION_BLOCK: /END_FUNCTION_BLOCK/,
    VAR_INPUT: /VAR_INPUT/,
    VAR_OUTPUT: /VAR_OUTPUT/,
    VAR_IN_OUT: /VAR_IN_OUT/,
    VAR_EXTERNAL: /VAR_EXTERNAL/,
    VAR_GLOBAL: /VAR_GLOBAL/,
    VAR_TEMP: /VAR_TEMP/,
    END_PROGRAM: /END_PROGRAM/,
    END_FUNCTION: /END_FUNCTION/,
    END_WHILE: /END_WHILE/,
    END_REPEAT: /END_REPEAT/,
    END_STRUCT: /END_STRUCT/,
    END_IF: /END_IF/,
    END_FOR: /END_FOR/,
    END_VAR: /END_VAR/,
    END_CASE: /END_CASE/,
    FUNCTION: /FUNCTION/,
    PROGRAM: /PROGRAM/,
    REPEAT: /REPEAT/,
    STRUCT: /STRUCT/,
    WHILE: /WHILE/,
    ARRAY: /ARRAY/,
    BEGIN: /BEGIN/,
    ELSIF: /ELSIF/,
    UNTIL: /UNTIL/,
    ELSE: /ELSE/,
    THEN: /THEN/,
    CONSTANT: /CONSTANT/,
    RETAIN: /RETAIN/,
    VAR: /VAR/,
    FOR: /FOR/,
    END: /END/,
    IF: /IF/,
    OF: /OF/,
    TO: /TO/,
    BY: /BY/,
    DO: /DO/,
    CASE: /CASE/,
    RETURN: /RETURN/,
    TRUE: /TRUE/,
    FALSE: /FALSE/,
    AND: /AND/,
    OR: /OR/,
    XOR: /XOR/,
    NOT: /NOT/,
    MOD: /MOD/,
    HEX_NUMBER: /16#[0-9A-Fa-f]+/,
    BIN_NUMBER: /2#[01]+/,
    OCT_NUMBER: /8#[0-7]+/,
    TIME_LITERAL: /T#[0-9smhd_]+/,
    DATE_LITERAL: /D#\d{4}-\d{1,2}-\d{1,2}/,
    ID: /[a-zA-Z_][a-zA-Z0-9_]*/,
    NUMBER: /-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?/,
    STRING: /"([^"\\]|\\.)*"|'([^'\\]|\\.)*'/,
    LESS_EQUAL: /<=/,
    GREATER_EQUAL: />=/,
    NOT_EQUAL: /<>/,
    ASSIGN: /:=/,
    INIT: /=>/,
    RANGE: /\.\./,
    EQUAL: /=/,
    LESS: /</,
    GREATER: />/,
    PLUS: /\+/,
    MINUS: /-/,
    MULTIPLY: /\*/,
    DIVIDE: /\//,
    DOT: /\./,
    COMMA: /,/,
    SEMICOLON: /;/,
    COLON: /:/,
    LPAREN: /\(/,
    RPAREN: /\)/,
    LBRACKET: /\[/,
    RBRACKET: /\]/,
};

export type IEC61131TerminalNames = keyof typeof IEC61131Terminals;

export type IEC61131KeywordNames = 
    | "END_TYPE"
    | "TYPE";

export type IEC61131TokenNames = IEC61131TerminalNames | IEC61131KeywordNames;

export type BinaryOperator = string;

export function isBinaryOperator(item: unknown): item is BinaryOperator {
    return (typeof item === 'string' && (/OR/.test(item) || /XOR/.test(item) || /AND/.test(item) || /=/.test(item) || /<>/.test(item) || /</.test(item) || /<=/.test(item) || />/.test(item) || />=/.test(item) || /\+/.test(item) || /-/.test(item) || /\*/.test(item) || /\//.test(item) || /MOD/.test(item)));
}

export type BoolLiteral = boolean;

export function isBoolLiteral(item: unknown): item is BoolLiteral {
    return typeof item === 'boolean';
}

export type Expression = BinaryExpression | PrimaryExpression | UnaryExpression;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type PrimaryExpression = FunctionCallExpression | Literal | ParenExpression | VariableReference;

export const PrimaryExpression = 'PrimaryExpression';

export function isPrimaryExpression(item: unknown): item is PrimaryExpression {
    return reflection.isInstance(item, PrimaryExpression);
}

export type Statement = Assignment | CaseStatement | ForStatement | FunctionCall | IfStatement | RepeatStatement | ReturnStatement | WhileStatement;

export const Statement = 'Statement';

export function isStatement(item: unknown): item is Statement {
    return reflection.isInstance(item, Statement);
}

export type TypeDecl = ArrayType | EnumTypeReference | SimpleType | StructType;

export const TypeDecl = 'TypeDecl';

export function isTypeDecl(item: unknown): item is TypeDecl {
    return reflection.isInstance(item, TypeDecl);
}

export type UnaryOperator = string;

export function isUnaryOperator(item: unknown): item is UnaryOperator {
    return (typeof item === 'string' && (/NOT/.test(item) || /-/.test(item)));
}

export interface Argument extends AstNode {
    readonly $container: Call;
    readonly $type: 'Argument';
    name?: string;
    value: Expression;
}

export const Argument = 'Argument';

export function isArgument(item: unknown): item is Argument {
    return reflection.isInstance(item, Argument);
}

export interface ArrayDimension extends AstNode {
    readonly $container: ArrayType;
    readonly $type: 'ArrayDimension';
    end: number | string;
    start: number | string;
}

export const ArrayDimension = 'ArrayDimension';

export function isArrayDimension(item: unknown): item is ArrayDimension {
    return reflection.isInstance(item, ArrayDimension);
}

export interface ArrayType extends AstNode {
    readonly $container: ArrayType | FunctionDef | VariableDecl;
    readonly $type: 'ArrayType';
    dimensions: Array<ArrayDimension>;
    type: TypeDecl;
}

export const ArrayType = 'ArrayType';

export function isArrayType(item: unknown): item is ArrayType {
    return reflection.isInstance(item, ArrayType);
}

export interface Assignment extends AstNode {
    readonly $container: CaseStatement | ForStatement | IfStatement | ProgramBody | RepeatStatement | WhileStatement;
    readonly $type: 'Assignment';
    target: LeftExpression;
    value: Expression;
}

export const Assignment = 'Assignment';

export function isAssignment(item: unknown): item is Assignment {
    return reflection.isInstance(item, Assignment);
}

export interface BinaryExpression extends AstNode {
    readonly $container: Argument | Assignment | BinaryExpression | CaseStatement | ElementAccess | ForStatement | IfStatement | ParenExpression | RepeatStatement | ReturnStatement | VariableDecl | WhileStatement;
    readonly $type: 'BinaryExpression';
    left: PrimaryExpression;
    operator: BinaryOperator;
    right: Expression;
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface Call extends AstNode {
    readonly $container: FunctionCall | FunctionCallExpression;
    readonly $type: 'Call';
    args: Array<Argument>;
    func?: Reference<FunctionDef>;
    variable?: Reference<VariableDecl>;
}

export const Call = 'Call';

export function isCall(item: unknown): item is Call {
    return reflection.isInstance(item, Call);
}

export interface CaseStatement extends AstNode {
    readonly $container: CaseStatement | ForStatement | IfStatement | ProgramBody | RepeatStatement | WhileStatement;
    readonly $type: 'CaseStatement';
    caseLabels: Array<Expression>;
    caseStatements: Array<Statement>;
    defaultStatements: Array<Statement>;
    expression: Expression;
}

export const CaseStatement = 'CaseStatement';

export function isCaseStatement(item: unknown): item is CaseStatement {
    return reflection.isInstance(item, CaseStatement);
}

export interface ElementAccess extends AstNode {
    readonly $container: LeftExpression | VariableReference;
    readonly $type: 'ElementAccess';
    index?: Expression;
    member: string;
}

export const ElementAccess = 'ElementAccess';

export function isElementAccess(item: unknown): item is ElementAccess {
    return reflection.isInstance(item, ElementAccess);
}

export interface EnumType extends AstNode {
    readonly $container: Program;
    readonly $type: 'EnumType';
    enumValues: Array<EnumValue>;
    name: string;
}

export const EnumType = 'EnumType';

export function isEnumType(item: unknown): item is EnumType {
    return reflection.isInstance(item, EnumType);
}

export interface EnumTypeReference extends AstNode {
    readonly $container: ArrayType | FunctionDef | VariableDecl;
    readonly $type: 'EnumTypeReference';
    type: Reference<EnumType>;
}

export const EnumTypeReference = 'EnumTypeReference';

export function isEnumTypeReference(item: unknown): item is EnumTypeReference {
    return reflection.isInstance(item, EnumTypeReference);
}

export interface EnumValue extends AstNode {
    readonly $container: EnumType;
    readonly $type: 'EnumValue';
    name: string;
    value?: number;
}

export const EnumValue = 'EnumValue';

export function isEnumValue(item: unknown): item is EnumValue {
    return reflection.isInstance(item, EnumValue);
}

export interface ForStatement extends AstNode {
    readonly $container: CaseStatement | ForStatement | IfStatement | ProgramBody | RepeatStatement | WhileStatement;
    readonly $type: 'ForStatement';
    end: Expression;
    start: Expression;
    statements: Array<Statement>;
    step?: Expression;
    variable: string;
}

export const ForStatement = 'ForStatement';

export function isForStatement(item: unknown): item is ForStatement {
    return reflection.isInstance(item, ForStatement);
}

export interface FunctionBlock extends AstNode {
    readonly $container: Program;
    readonly $type: 'FunctionBlock';
    body: ProgramBody;
    name: string;
    varDeclarations: Array<VarDeclaration>;
}

export const FunctionBlock = 'FunctionBlock';

export function isFunctionBlock(item: unknown): item is FunctionBlock {
    return reflection.isInstance(item, FunctionBlock);
}

export interface FunctionCall extends AstNode {
    readonly $container: CaseStatement | ForStatement | IfStatement | ProgramBody | RepeatStatement | WhileStatement;
    readonly $type: 'FunctionCall';
    call: Call;
}

export const FunctionCall = 'FunctionCall';

export function isFunctionCall(item: unknown): item is FunctionCall {
    return reflection.isInstance(item, FunctionCall);
}

export interface FunctionCallExpression extends AstNode {
    readonly $container: Argument | Assignment | BinaryExpression | CaseStatement | ElementAccess | ForStatement | IfStatement | ParenExpression | RepeatStatement | ReturnStatement | UnaryExpression | VariableDecl | WhileStatement;
    readonly $type: 'FunctionCallExpression';
    call: Call;
}

export const FunctionCallExpression = 'FunctionCallExpression';

export function isFunctionCallExpression(item: unknown): item is FunctionCallExpression {
    return reflection.isInstance(item, FunctionCallExpression);
}

export interface FunctionDef extends AstNode {
    readonly $container: Program;
    readonly $type: 'FunctionDef';
    body: ProgramBody;
    name: string;
    returnType: TypeDecl;
    varDeclarations: Array<VarDeclaration>;
}

export const FunctionDef = 'FunctionDef';

export function isFunctionDef(item: unknown): item is FunctionDef {
    return reflection.isInstance(item, FunctionDef);
}

export interface IfStatement extends AstNode {
    readonly $container: CaseStatement | ForStatement | IfStatement | ProgramBody | RepeatStatement | WhileStatement;
    readonly $type: 'IfStatement';
    condition: Expression;
    elseIfConditions: Array<Expression>;
    elseIfStatements: Array<Statement>;
    elseStatements: Array<Statement>;
    thenStatements: Array<Statement>;
}

export const IfStatement = 'IfStatement';

export function isIfStatement(item: unknown): item is IfStatement {
    return reflection.isInstance(item, IfStatement);
}

export interface LeftExpression extends AstNode {
    readonly $container: Assignment;
    readonly $type: 'LeftExpression';
    elements: Array<ElementAccess>;
}

export const LeftExpression = 'LeftExpression';

export function isLeftExpression(item: unknown): item is LeftExpression {
    return reflection.isInstance(item, LeftExpression);
}

export interface Literal extends AstNode {
    readonly $container: Argument | Assignment | BinaryExpression | CaseStatement | ElementAccess | ForStatement | IfStatement | ParenExpression | RepeatStatement | ReturnStatement | UnaryExpression | VariableDecl | WhileStatement;
    readonly $type: 'Literal';
    value: BoolLiteral | number | string;
}

export const Literal = 'Literal';

export function isLiteral(item: unknown): item is Literal {
    return reflection.isInstance(item, Literal);
}

export interface ParenExpression extends AstNode {
    readonly $container: Argument | Assignment | BinaryExpression | CaseStatement | ElementAccess | ForStatement | IfStatement | ParenExpression | RepeatStatement | ReturnStatement | UnaryExpression | VariableDecl | WhileStatement;
    readonly $type: 'ParenExpression';
    expr: Expression;
}

export const ParenExpression = 'ParenExpression';

export function isParenExpression(item: unknown): item is ParenExpression {
    return reflection.isInstance(item, ParenExpression);
}

export interface Program extends AstNode {
    readonly $type: 'Program';
    enumTypes: Array<EnumType>;
    functionBlocks: Array<FunctionBlock>;
    functions: Array<FunctionDef>;
    programs: Array<ProgramDecl>;
}

export const Program = 'Program';

export function isProgram(item: unknown): item is Program {
    return reflection.isInstance(item, Program);
}

export interface ProgramBody extends AstNode {
    readonly $container: FunctionBlock | FunctionDef | ProgramDecl;
    readonly $type: 'ProgramBody';
    statements: Array<Statement>;
}

export const ProgramBody = 'ProgramBody';

export function isProgramBody(item: unknown): item is ProgramBody {
    return reflection.isInstance(item, ProgramBody);
}

export interface ProgramDecl extends AstNode {
    readonly $container: Program;
    readonly $type: 'ProgramDecl';
    body: ProgramBody;
    name: string;
    varDeclarations: Array<VarDeclaration>;
}

export const ProgramDecl = 'ProgramDecl';

export function isProgramDecl(item: unknown): item is ProgramDecl {
    return reflection.isInstance(item, ProgramDecl);
}

export interface RepeatStatement extends AstNode {
    readonly $container: CaseStatement | ForStatement | IfStatement | ProgramBody | RepeatStatement | WhileStatement;
    readonly $type: 'RepeatStatement';
    condition: Expression;
    statements: Array<Statement>;
}

export const RepeatStatement = 'RepeatStatement';

export function isRepeatStatement(item: unknown): item is RepeatStatement {
    return reflection.isInstance(item, RepeatStatement);
}

export interface ReturnStatement extends AstNode {
    readonly $container: CaseStatement | ForStatement | IfStatement | ProgramBody | RepeatStatement | WhileStatement;
    readonly $type: 'ReturnStatement';
    value?: Expression;
}

export const ReturnStatement = 'ReturnStatement';

export function isReturnStatement(item: unknown): item is ReturnStatement {
    return reflection.isInstance(item, ReturnStatement);
}

export interface SimpleType extends AstNode {
    readonly $container: ArrayType | FunctionDef | VariableDecl;
    readonly $type: 'SimpleType';
    name: string;
}

export const SimpleType = 'SimpleType';

export function isSimpleType(item: unknown): item is SimpleType {
    return reflection.isInstance(item, SimpleType);
}

export interface StructType extends AstNode {
    readonly $container: ArrayType | FunctionDef | VariableDecl;
    readonly $type: 'StructType';
    fields: Array<VariableDecl>;
}

export const StructType = 'StructType';

export function isStructType(item: unknown): item is StructType {
    return reflection.isInstance(item, StructType);
}

export interface UnaryExpression extends AstNode {
    readonly $container: Argument | Assignment | BinaryExpression | CaseStatement | ElementAccess | ForStatement | IfStatement | ParenExpression | RepeatStatement | ReturnStatement | VariableDecl | WhileStatement;
    readonly $type: 'UnaryExpression';
    operand: PrimaryExpression;
    operator: UnaryOperator;
}

export const UnaryExpression = 'UnaryExpression';

export function isUnaryExpression(item: unknown): item is UnaryExpression {
    return reflection.isInstance(item, UnaryExpression);
}

export interface VarDeclaration extends AstNode {
    readonly $container: FunctionBlock | FunctionDef | ProgramDecl;
    readonly $type: 'VarDeclaration';
    variables: Array<VariableDecl>;
}

export const VarDeclaration = 'VarDeclaration';

export function isVarDeclaration(item: unknown): item is VarDeclaration {
    return reflection.isInstance(item, VarDeclaration);
}

export interface VariableDecl extends AstNode {
    readonly $container: StructType | VarDeclaration;
    readonly $type: 'VariableDecl';
    initialValue?: Expression;
    name: string;
    type: TypeDecl;
}

export const VariableDecl = 'VariableDecl';

export function isVariableDecl(item: unknown): item is VariableDecl {
    return reflection.isInstance(item, VariableDecl);
}

export interface VariableReference extends AstNode {
    readonly $container: Argument | Assignment | BinaryExpression | CaseStatement | ElementAccess | ForStatement | IfStatement | ParenExpression | RepeatStatement | ReturnStatement | UnaryExpression | VariableDecl | WhileStatement;
    readonly $type: 'VariableReference';
    elements: Array<ElementAccess>;
}

export const VariableReference = 'VariableReference';

export function isVariableReference(item: unknown): item is VariableReference {
    return reflection.isInstance(item, VariableReference);
}

export interface WhileStatement extends AstNode {
    readonly $container: CaseStatement | ForStatement | IfStatement | ProgramBody | RepeatStatement | WhileStatement;
    readonly $type: 'WhileStatement';
    condition: Expression;
    statements: Array<Statement>;
}

export const WhileStatement = 'WhileStatement';

export function isWhileStatement(item: unknown): item is WhileStatement {
    return reflection.isInstance(item, WhileStatement);
}

export type IEC61131AstType = {
    Argument: Argument
    ArrayDimension: ArrayDimension
    ArrayType: ArrayType
    Assignment: Assignment
    BinaryExpression: BinaryExpression
    Call: Call
    CaseStatement: CaseStatement
    ElementAccess: ElementAccess
    EnumType: EnumType
    EnumTypeReference: EnumTypeReference
    EnumValue: EnumValue
    Expression: Expression
    ForStatement: ForStatement
    FunctionBlock: FunctionBlock
    FunctionCall: FunctionCall
    FunctionCallExpression: FunctionCallExpression
    FunctionDef: FunctionDef
    IfStatement: IfStatement
    LeftExpression: LeftExpression
    Literal: Literal
    ParenExpression: ParenExpression
    PrimaryExpression: PrimaryExpression
    Program: Program
    ProgramBody: ProgramBody
    ProgramDecl: ProgramDecl
    RepeatStatement: RepeatStatement
    ReturnStatement: ReturnStatement
    SimpleType: SimpleType
    Statement: Statement
    StructType: StructType
    TypeDecl: TypeDecl
    UnaryExpression: UnaryExpression
    VarDeclaration: VarDeclaration
    VariableDecl: VariableDecl
    VariableReference: VariableReference
    WhileStatement: WhileStatement
}

export class IEC61131AstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return [Argument, ArrayDimension, ArrayType, Assignment, BinaryExpression, Call, CaseStatement, ElementAccess, EnumType, EnumTypeReference, EnumValue, Expression, ForStatement, FunctionBlock, FunctionCall, FunctionCallExpression, FunctionDef, IfStatement, LeftExpression, Literal, ParenExpression, PrimaryExpression, Program, ProgramBody, ProgramDecl, RepeatStatement, ReturnStatement, SimpleType, Statement, StructType, TypeDecl, UnaryExpression, VarDeclaration, VariableDecl, VariableReference, WhileStatement];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case ArrayType:
            case EnumTypeReference:
            case SimpleType:
            case StructType: {
                return this.isSubtype(TypeDecl, supertype);
            }
            case Assignment:
            case CaseStatement:
            case ForStatement:
            case FunctionCall:
            case IfStatement:
            case RepeatStatement:
            case ReturnStatement:
            case WhileStatement: {
                return this.isSubtype(Statement, supertype);
            }
            case BinaryExpression:
            case PrimaryExpression:
            case UnaryExpression: {
                return this.isSubtype(Expression, supertype);
            }
            case FunctionCallExpression:
            case Literal:
            case ParenExpression:
            case VariableReference: {
                return this.isSubtype(PrimaryExpression, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Call:func': {
                return FunctionDef;
            }
            case 'Call:variable': {
                return VariableDecl;
            }
            case 'EnumTypeReference:type': {
                return EnumType;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case Argument: {
                return {
                    name: Argument,
                    properties: [
                        { name: 'name' },
                        { name: 'value' }
                    ]
                };
            }
            case ArrayDimension: {
                return {
                    name: ArrayDimension,
                    properties: [
                        { name: 'end' },
                        { name: 'start' }
                    ]
                };
            }
            case ArrayType: {
                return {
                    name: ArrayType,
                    properties: [
                        { name: 'dimensions', defaultValue: [] },
                        { name: 'type' }
                    ]
                };
            }
            case Assignment: {
                return {
                    name: Assignment,
                    properties: [
                        { name: 'target' },
                        { name: 'value' }
                    ]
                };
            }
            case BinaryExpression: {
                return {
                    name: BinaryExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case Call: {
                return {
                    name: Call,
                    properties: [
                        { name: 'args', defaultValue: [] },
                        { name: 'func' },
                        { name: 'variable' }
                    ]
                };
            }
            case CaseStatement: {
                return {
                    name: CaseStatement,
                    properties: [
                        { name: 'caseLabels', defaultValue: [] },
                        { name: 'caseStatements', defaultValue: [] },
                        { name: 'defaultStatements', defaultValue: [] },
                        { name: 'expression' }
                    ]
                };
            }
            case ElementAccess: {
                return {
                    name: ElementAccess,
                    properties: [
                        { name: 'index' },
                        { name: 'member' }
                    ]
                };
            }
            case EnumType: {
                return {
                    name: EnumType,
                    properties: [
                        { name: 'enumValues', defaultValue: [] },
                        { name: 'name' }
                    ]
                };
            }
            case EnumTypeReference: {
                return {
                    name: EnumTypeReference,
                    properties: [
                        { name: 'type' }
                    ]
                };
            }
            case EnumValue: {
                return {
                    name: EnumValue,
                    properties: [
                        { name: 'name' },
                        { name: 'value' }
                    ]
                };
            }
            case ForStatement: {
                return {
                    name: ForStatement,
                    properties: [
                        { name: 'end' },
                        { name: 'start' },
                        { name: 'statements', defaultValue: [] },
                        { name: 'step' },
                        { name: 'variable' }
                    ]
                };
            }
            case FunctionBlock: {
                return {
                    name: FunctionBlock,
                    properties: [
                        { name: 'body' },
                        { name: 'name' },
                        { name: 'varDeclarations', defaultValue: [] }
                    ]
                };
            }
            case FunctionCall: {
                return {
                    name: FunctionCall,
                    properties: [
                        { name: 'call' }
                    ]
                };
            }
            case FunctionCallExpression: {
                return {
                    name: FunctionCallExpression,
                    properties: [
                        { name: 'call' }
                    ]
                };
            }
            case FunctionDef: {
                return {
                    name: FunctionDef,
                    properties: [
                        { name: 'body' },
                        { name: 'name' },
                        { name: 'returnType' },
                        { name: 'varDeclarations', defaultValue: [] }
                    ]
                };
            }
            case IfStatement: {
                return {
                    name: IfStatement,
                    properties: [
                        { name: 'condition' },
                        { name: 'elseIfConditions', defaultValue: [] },
                        { name: 'elseIfStatements', defaultValue: [] },
                        { name: 'elseStatements', defaultValue: [] },
                        { name: 'thenStatements', defaultValue: [] }
                    ]
                };
            }
            case LeftExpression: {
                return {
                    name: LeftExpression,
                    properties: [
                        { name: 'elements', defaultValue: [] }
                    ]
                };
            }
            case Literal: {
                return {
                    name: Literal,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case ParenExpression: {
                return {
                    name: ParenExpression,
                    properties: [
                        { name: 'expr' }
                    ]
                };
            }
            case Program: {
                return {
                    name: Program,
                    properties: [
                        { name: 'enumTypes', defaultValue: [] },
                        { name: 'functionBlocks', defaultValue: [] },
                        { name: 'functions', defaultValue: [] },
                        { name: 'programs', defaultValue: [] }
                    ]
                };
            }
            case ProgramBody: {
                return {
                    name: ProgramBody,
                    properties: [
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case ProgramDecl: {
                return {
                    name: ProgramDecl,
                    properties: [
                        { name: 'body' },
                        { name: 'name' },
                        { name: 'varDeclarations', defaultValue: [] }
                    ]
                };
            }
            case RepeatStatement: {
                return {
                    name: RepeatStatement,
                    properties: [
                        { name: 'condition' },
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            case ReturnStatement: {
                return {
                    name: ReturnStatement,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case SimpleType: {
                return {
                    name: SimpleType,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case StructType: {
                return {
                    name: StructType,
                    properties: [
                        { name: 'fields', defaultValue: [] }
                    ]
                };
            }
            case UnaryExpression: {
                return {
                    name: UnaryExpression,
                    properties: [
                        { name: 'operand' },
                        { name: 'operator' }
                    ]
                };
            }
            case VarDeclaration: {
                return {
                    name: VarDeclaration,
                    properties: [
                        { name: 'variables', defaultValue: [] }
                    ]
                };
            }
            case VariableDecl: {
                return {
                    name: VariableDecl,
                    properties: [
                        { name: 'initialValue' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case VariableReference: {
                return {
                    name: VariableReference,
                    properties: [
                        { name: 'elements', defaultValue: [] }
                    ]
                };
            }
            case WhileStatement: {
                return {
                    name: WhileStatement,
                    properties: [
                        { name: 'condition' },
                        { name: 'statements', defaultValue: [] }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new IEC61131AstReflection();
